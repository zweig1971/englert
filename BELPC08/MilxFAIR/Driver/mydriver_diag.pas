{
 --------------------------------------------------------------
 File - mydriver_diag.pas

 This is a diagnostics application for accessing the MYDRIVER card.
 Code was generated by Driver Wizard.
 It accesses the hardware via WinDriver functions.
 --------------------------------------------------------------
}

unit mydriver_diag;

interface

uses
    Windows,
    SysUtils,
    Windrvr,
    Print_Struct,
    PCI_Diag_Lib,
    MYDRIVER_lib;

var
    { input of command from user }
    line : STRING[255];

procedure main;


implementation

procedure MYDRIVER_AccessRegisters(hMYDRIVER : MYDRIVER_HANDLE);
var
    cmd : INTEGER;
    data : DWORD;

begin
    repeat
    begin
        Writeln('');
        Writeln('Access MYDRIVER registers');
        Writeln('--------------------------------');
        Writeln('                               1. Write to Mil_cmd           ');
        Writeln('                               2. Write to Mil_write         ');
        Writeln('                               3. Write to Reset_Card        ');
        Writeln('4. Read from Mil_read                                        ');
        Writeln('                               5. Write to Set_Timer1        ');
        Writeln('6. Read from Mil_Status                                      ');
        Writeln('                               7. Write to ControlRegister1  ');
        Writeln('                               8. Write to Slave_Mil_interlog');
        Writeln('9. Read from EV_Time_Rd                                      ');
        Writeln('10. Read from Event_Read                                     ');
        Writeln('11. Read from Intrrrupt_Mask   12. Write to Intrrrupt_Mask   ');
        Writeln('13. Read from Aux_IO           14. Write to Aux_IO           ');
        Writeln('                               15. Write to Set_Timer2_10us  ');
        Writeln('                               16. Write to Set_Timer2_1ms   ');
        Writeln('99. Back to main menu');
        Writeln('Choose register to write to, or 99 to exit: ');
        data := 0;
        cmd := 0;
        Readln(cmd);
        case cmd of
        1:
            begin
                Write('Enter value to write to Mil_cmd register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteMil_cmd( hMYDRIVER, (data));
                end;
            end;
        2:
            begin
                Write('Enter value to write to Mil_write register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteMil_write( hMYDRIVER, (data));
                end;
            end;
        3:
            begin
                Write('Enter value to write to Reset_Card register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteReset_Card( hMYDRIVER, (data));
                end;
            end;
        4:
            begin
                data := MYDRIVER_ReadMil_read(hMYDRIVER);
                Writeln('Value read from Mil_read register: ', IntToHex(data,8));
            end;
        5:
            begin
                Write('Enter value to write to Set_Timer1 register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteSet_Timer1( hMYDRIVER, (data));
                end;
            end;
        6:
            begin
                data := MYDRIVER_ReadMil_Status(hMYDRIVER);
                Writeln('Value read from Mil_Status register: ', IntToHex(data,8));
            end;
        7:
            begin
                Write('Enter value to write to ControlRegister1 register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteControlRegister1( hMYDRIVER, (data));
                end;
            end;
        8:
            begin
                Write('Enter value to write to Slave_Mil_interlog register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteSlave_Mil_interlog( hMYDRIVER, (data));
                end;
            end;
        9:
            begin
                data := MYDRIVER_ReadEV_Time_Rd(hMYDRIVER);
                Writeln('Value read from EV_Time_Rd register: ', IntToHex(data,8));
            end;
        10:
            begin
                data := MYDRIVER_ReadEvent_Read(hMYDRIVER);
                Writeln('Value read from Event_Read register: ', IntToHex(data,8));
            end;
        11:
            begin
                data := MYDRIVER_ReadIntrrrupt_Mask(hMYDRIVER);
                Writeln('Value read from Intrrrupt_Mask register: ', IntToHex(data,8));
            end;
        12:
            begin
                Write('Enter value to write to Intrrrupt_Mask register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteIntrrrupt_Mask( hMYDRIVER, (data));
                end;
            end;
        13:
            begin
                data := MYDRIVER_ReadAux_IO(hMYDRIVER);
                Writeln('Value read from Aux_IO register: ', IntToHex(data,8));
            end;
        14:
            begin
                Write('Enter value to write to Aux_IO register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteAux_IO( hMYDRIVER, (data));
                end;
            end;
        15:
            begin
                Write('Enter value to write to Set_Timer2_10us register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteSet_Timer2_10us( hMYDRIVER, (data));
                end;
            end;
        16:
            begin
                Write('Enter value to write to Set_Timer2_1ms register (or <X> to cancel): ');
                Readln(line);
                if (line <> 'X') and (line <> 'x')
                then
                begin
                    data := HexToInt(line);
                    MYDRIVER_WriteSet_Timer2_1ms( hMYDRIVER, (data));
                end;
            end;
        end;
    end;
    until (cmd=99);
end;


function MYDRIVER_GetAddrSpaceName(addrSpace : MYDRIVER_ADDR) : PCHAR;
begin
    case addrSpace of
    MYDRIVER_AD_BAR0 :
        MYDRIVER_GetAddrSpaceName := PCHAR('Addr Space BAR0');
    MYDRIVER_AD_BAR1 :
        MYDRIVER_GetAddrSpaceName := PCHAR('Addr Space BAR1');
    MYDRIVER_AD_BAR2 :
        MYDRIVER_GetAddrSpaceName := PCHAR('Addr Space BAR2');
    MYDRIVER_AD_BAR3 :
        MYDRIVER_GetAddrSpaceName := PCHAR('Addr Space BAR3');
    MYDRIVER_AD_BAR4 :
        MYDRIVER_GetAddrSpaceName := PCHAR('Addr Space BAR4');
    MYDRIVER_AD_BAR5 :
        MYDRIVER_GetAddrSpaceName := PCHAR('Addr Space BAR5');
    MYDRIVER_AD_EPROM :
        MYDRIVER_GetAddrSpaceName := PCHAR('EEPROM Addr Space');
    else
        MYDRIVER_GetAddrSpaceName := PCHAR('Invalid');
    end;
end;


procedure MYDRIVER_AccessRanges(hMYDRIVER : MYDRIVER_HANDLE);
var
    cmd, cmd2, i : INTEGER;
    addr, data   : DWORD;
    ad_sp        : MYDRIVER_ADDR;
    ad_mode      : MYDRIVER_MODE;
    sMode        : STRING[20];

begin
    ad_sp   := 0;
    ad_mode := MYDRIVER_MODE_DWORD;
    while (ad_sp < MYDRIVER_ITEMS) and (not MYDRIVER_IsAddrSpaceActive(hMYDRIVER, ad_sp)) do
    begin
        if ad_sp = MYDRIVER_ITEMS
        then
        begin
            Writeln('No active memory or IO ranges on board!');
            Exit;
        end;
        ad_sp := ad_sp+1;
    end;
    repeat
    begin
        case ad_mode of
        MYDRIVER_MODE_BYTE :
            sMode := 'BYTE (8 bit)';
        MYDRIVER_MODE_WORD :
            sMode := 'WORD (16 bit)';
        MYDRIVER_MODE_DWORD :
            sMode := 'DWORD (32 bit)';
        end;
        Writeln('Access the board memory and IO ranges');
        Writeln('---------------------------------------');
        Writeln('1.  Change active memory space: ',MYDRIVER_GetAddrSpaceName(ad_sp));
        Writeln('2.  Toggle active mode: ', sMode);
        Writeln('3.  Read from board');
        Writeln('4.  Write to board');
        Writeln('99. Back to main menu');
        Write('Enter option: ');
        cmd := 0;
        Readln(line);
        cmd := StringToInt(line);
        case cmd of
        1:
            begin
                Writeln('Choose memory or IO space:');
                Writeln('--------------------------');
                for i:=1 to MYDRIVER_ITEMS do
                begin
                    Write(i, '. ', MYDRIVER_GetAddrSpaceName(i-1));
                    if not MYDRIVER_IsAddrSpaceActive(hMYDRIVER, MYDRIVER_ADDR (i-1))
                    then
                        Write(' - space not active');
                    Writeln('');
                end;
                Write('Enter option: ');
                cmd2 := 99;
                Readln(line);
                cmd2 := StringToInt(line);
                if (cmd2>=1) and (cmd2<MYDRIVER_ITEMS+1)
                then
                begin
                    ad_sp := cmd2-1;
                    if not MYDRIVER_IsAddrSpaceActive(hMYDRIVER, ad_sp)
                    then
                        Writeln('Chosen space not active!');
                end;
            end;
        2:
            ad_mode := (ad_mode + 1) mod 3;
        3:
            begin
                Write('Enter offset to read from: ');
                Readln(line);
                addr := HexToInt(line);
                case ad_mode of
                MYDRIVER_MODE_BYTE:
                    data := MYDRIVER_ReadByte(hMYDRIVER, ad_sp, addr);
                MYDRIVER_MODE_WORD:
                    data := MYDRIVER_ReadWord(hMYDRIVER, ad_sp, addr);
                MYDRIVER_MODE_DWORD:
                    data := MYDRIVER_ReadDword(hMYDRIVER, ad_sp, addr);
                end;
                Writeln('Value read: ', IntToHex(data,8));
            end;
        4:
            begin
                Write('Enter offset to write to: ');
                Readln(line);
                addr := HexToInt(line);
                Write('Enter data to write ', sMode, ': ');
                Readln(line);
                data := HexToInt(line);
                case ad_mode of
                MYDRIVER_MODE_BYTE:
                    MYDRIVER_WriteByte(hMYDRIVER, ad_sp, addr, BYTE (data));
                MYDRIVER_MODE_WORD:
                    MYDRIVER_WriteWord(hMYDRIVER, ad_sp, addr, WORD (data));
                MYDRIVER_MODE_DWORD:
                    MYDRIVER_WriteDword(hMYDRIVER, ad_sp, addr, data);
                end;
            end;
        end;
    end;
    until cmd=99;
end;


procedure MYDRIVER_IntHandlerRoutine(pWorker : POINTER; intResult : PMYDRIVER_INT_RESULT) stdcall;
begin
    Writeln('Got Int number ', intResult^.dwCounter);
end;


procedure MYDRIVER_EnableDisableInterrupts(hMYDRIVER : MYDRIVER_HANDLE);
var
    cmd  : INTEGER;
    sAct : STRING[10];

begin
    Writeln('WARNING!!!');
    Writeln('----------');
    Writeln('Your hardware has level sensitive interrupts.');
    Writeln('You must modify the source code of MYDRIVER_IntEnable(), in the file mydriver_lib.pas,');
    Writeln('to acknowledge the interrupt before enabling interrupts.');
    Writeln('Without this modification, your PC will HANG upon interrupt!');
    Writeln('');

    repeat
    begin
        Writeln('Enable / Disable interrupts');
        Writeln('---------------------------');
        if MYDRIVER_IntIsEnabled(hMYDRIVER)
        then
            sAct := 'Disable '
        else
            sAct := 'Enable ';
        Writeln('1. ', sAct, 'Int');
        Writeln('99. Back to main menu');
        Write('Enter option: ');
        cmd := 0;
        Readln(line);
        cmd := StringToInt(line);
        case cmd of
        1:
            if MYDRIVER_IntIsEnabled(hMYDRIVER)
            then
            begin
                Writeln('Disabling interrupt Int');
                MYDRIVER_IntDisable(hMYDRIVER);
            end
            else
            begin
                Writeln('Enabling interrupt Int');
                if not MYDRIVER_IntEnable(hMYDRIVER, MYDRIVER_IntHandlerRoutine)
                then
                    Writeln('failed enabling interrupt Int');
            end;
        end;
    end;
    until cmd=99;
end;


function MYDRIVER_LocateAndOpenBoard(dwVendorID : DWORD; dwDeviceID : DWORD; fUseInt : BOOLEAN) : MYDRIVER_HANDLE;
var
    cards, my_card : DWORD;
    hMYDRIVER : MYDRIVER_HANDLE;
    i : DWORD;
    openParam : INTEGER;

begin
    hMYDRIVER := nil;
    if dwVendorID = 0 then
    begin
        Write('Enter VendorID: ');
        Readln(line);
        dwVendorID := HexToInt(line);
        if dwVendorID = 0 then
        begin
            MYDRIVER_LocateAndOpenBoard := nil;
            Exit;
        end;

        Write('Enter DeviceID: ');
        Readln(line);
        dwDeviceID := HexToInt(line);
    end;
    cards := MYDRIVER_CountCards (dwVendorID, dwDeviceID);
    if cards = 0 then
    begin
        Writeln(MYDRIVER_ErrorString);
        MYDRIVER_LocateAndOpenBoard := nil;
        Exit;
    end
    else
    begin
        if cards = 1
        then
            my_card := 1
        else
        begin
            i := 0;
            Writeln('Found ', cards, ' matching PCI cards');
            repeat
            begin
                Write('Select card (1-', cards, '): ');
                Readln(line);
                i := StringToInt(line);
            end;
            until (i>=1) and (i<=cards);
            my_card := i
        end;
    end;
    if fUseInt
    then
        openParam := MYDRIVER_OPEN_USE_INT
    else
        openParam := 0;
    if MYDRIVER_Open (@hMYDRIVER, dwVendorID, dwDeviceID, my_card - 1, openParam) then
        Writeln('MYDRIVER', ' ', 'PCI', ' card found!')
    else
        Writeln(MYDRIVER_ErrorString);
    MYDRIVER_LocateAndOpenBoard := hMYDRIVER;
end;


procedure main;
var
    cmd : INTEGER;
    hMYDRIVER : MYDRIVER_HANDLE;
    hWD : HANDLE;
    fUseInt: BOOLEAN;
    fOpenedWithInt : BOOLEAN;
    pciSlot : WD_PCI_SLOT;

begin
    hMYDRIVER := nil;
    fUseInt := False; { by default - do not install interrupts }
    fOpenedWithInt := fUseInt;

    Writeln('MYDRIVER diagnostic utility.');
    Writeln('Application accesses hardware using WinDriver.');

    { make sure WinDriver is loaded }
    if not PCI_Get_WD_handle(@hWD)
    then
        Exit;
    WD_Close(hWD);

    if MYDRIVER_DEFAULT_VENDOR_ID <> 0
    then
        hMYDRIVER := MYDRIVER_LocateAndOpenBoard(MYDRIVER_DEFAULT_VENDOR_ID, MYDRIVER_DEFAULT_DEVICE_ID, fUseInt);

    repeat
    begin
        Writeln('');
        Writeln('MYDRIVER main menu');
        Writeln('-------------------');
        Writeln('1.  Scan PCI bus');
        if fUseInt
        then
        begin
            Writeln('2.  Set opening board without interrupts');
            Writeln('3.  Locate/Choose MYDRIVER board (with interrupts)');
        end
        else
        begin
            Writeln('2.  Set opening board with interrupts');
            Writeln('3.  Locate/Choose MYDRIVER board (without interrupts)');
        end;
        if hMYDRIVER <> nil
        then
        begin
            Writeln('4.  PCI configuration registers');
            Writeln('5.  Access MYDRIVER registers');
            Writeln('6.  Access MYDRIVER memory and IO ranges');
            if fOpenedWithInt
            then
                Writeln('7.  Enable / Disable interrupts');
        end;
        Writeln('99. Exit');
        Write('Enter option: ');
        cmd := 0;
        Readln(line);
        cmd := StringToInt(line);
        case cmd of
        1: { Scan PCI bus}
            PCI_Print_all_cards_info();
        2: { Set opening board with / without interrupts }
            fUseInt := not fUseInt;
        3: { Locate MYDRIVER board }
            begin
                if hMYDRIVER <> nil
                then
                    MYDRIVER_Close(hMYDRIVER);
                hMYDRIVER := MYDRIVER_LocateAndOpenBoard(0, 0, fUseInt);
                if hMYDRIVER = nil
                then
                    Writeln('MYDRIVER card open failed!');
                fOpenedWithInt := fUseInt;
            end;
        4: { PCI configuration registers }
            if hMYDRIVER <> nil
            then
            begin
                MYDRIVER_GetPciSlot(hMYDRIVER, @pciSlot);
                PCI_EditConfigReg(pciSlot);
            end;
        5: { Access MYDRIVER local registers }
            if hMYDRIVER <> nil
            then
                MYDRIVER_AccessRegisters(hMYDRIVER);
        6: { Access MYDRIVER memory and IO ranges }
            if hMYDRIVER <> nil
            then
                MYDRIVER_AccessRanges(hMYDRIVER);
        7: { Enable / Disable interrupts }
            if (hMYDRIVER <> nil) and fOpenedWithInt
            then
                MYDRIVER_EnableDisableInterrupts(hMYDRIVER);
        end;
    end;
    until cmd=99;

    if hMYDRIVER <> nil
    then
        MYDRIVER_Close(hMYDRIVER);
end;


end.