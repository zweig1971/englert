unit DATECH_1;  {Eine zus"tzliche Datentechnik Library TURBO PASCAL V 7.0}
{
  Changes:
  14.02.96      Erstellung
  20.03.96      NewKeyPressed wegen F11, F12
  03.07.96      Convert_To_Hex: variable Stringl"nge mit String[0]-Abfrage
  04.07.96      Cursor neu
  05.07.96      Read_Int mit Abbruch und Min-, Max-Wert
  28.08.96      Tabellen mit neuem Text + Loop-Anzeige
  23.09.96      Telefon-Liste
  30.04.97      Sub-Adr fÅr Identifikation Modulbus
  07.05.97      Festlegung Mod_Test_Nr global
  12.05.97      Erweiterung Modulbus ID
  03.09.97      TAsk_String
}
{$S-}
interface                 { Teil der UNIT-Deklaration }
uses Crt, {WinDos,} Graph, Dos;   {graph, dos wegen cursor}
const
 Fct_Reset      = $01;   {Reset fÅr IFC, gilt auch fÅr APL-IO-Bus}
 Fct_NG_Ein     = $02;   {Magnete Ein}
 Fct_NG_Aus     = $03;   {Magnete Aus}
 Fct_NG_Plus    = $04;   {Magnete Plus}
 Fct_NG_Minus   = $05;   {Magnete Minus}

 Fct_Wr_Sw1     = $06;   {Sollwert 1 schreiben}
 Fct_Wr_Sw2     = $07;   {Sollwert 2 schreiben}
 Fct_Wr_Sw3     = $08;   {Sollwert 3 schreiben}
 Fct_Wr_Sw4     = $09;   {Sollwert 4 schreiben}
 Fct_Wr_Sw5     = $0A;   {Sollwert 5 schreiben}

 Fct_Wr_Iob_Dta = $10;   {Setze Daten fÅr APL-IO-Bus bzw. Modulbus}
 Fct_Wr_Iob_Adr = $11;   {Setze Adr   fÅr APL-IO-Bus bzw. Modulbus}
 Fct_Set_IntMask= $12;   {Intr. Maske auf der IFC setzen}
 Fct_Wr_Echo    = $13;   {Sollwert fÅr Echo-Funktion}

 Fct_NG_Last1   = $14;   {Magnete Last 1}
 Fct_NG_Last2   = $15;   {Magnete Last 2}
 Fct_NG_Last3   = $16;   {Magnete Last 3}
 Fct_NG_Last4   = $17;   {Magnete Last 4}
 Fct_NG_Last5   = $18;   {Magnete Last 5}
 Fct_NG_Last0   = $19;   {Magnete Last 0}

 Fct_Rd_Ist1    = $81;   {Lese ADC-Wert}
 Fct_Rd_Ist2    = $82;
 Fct_Rd_Ist3    = $83;
 Fct_Rd_Ist4    = $84;

 Fct_Rd_Echo    = $89;   {Lese Echo Istwert}
 Fct_Rd_Ident   = $8E;   {16-bit breit: HiByte=not used, LoByte=Ident-code}
 Fct_Rd_Iob_Dta = $90;   {Lesen Daten von APL-IO-Bus bzw. Modulbus}
 Fct_Rd_FGStat1 = $91;   {Lesen FunktionsGenerator-Status}
 Fct_Rd_FGStat2 = $92;   {Lesen FG-Status}
 Fct_Rd_Stat0   = $C0;   {Lesen Status 0}
 Fct_Rd_Stat1   = $C1;   {Lesen Status 1}
 Fct_Rd_Stat2   = $C2;   {Lesen Status 3}
 Fct_Rd_Stat3   = $C3;   {Lesen Status 3}
 Fct_Rd_Status  = $C9;   {Status IFC-Karte}
 Fct_Rd_HS_Ctrl = $CA;   {Ctrl Maske Hochstrom-Interlock}
 Fct_Rd_HS_Status = $CB; {Status Maske Hochstrom-Interlock}
 Fct_Rd_IFK_ID  = $CC;   {Lesen Idencode der IFC-Karte}

 Ifk_Pigy_ModBus   = $06; {IFK 380.201 mit Modulbus-Piggy      Fct 8E[H] }
 Ifk_ID_ModBus     = $FD; {IFK 450.012 fÅr Modulbus: lesen mit Fct CC[H] }

 {Sub-Adr fÅr Modul-Bus Identifizierung: gÅltig fÅr alle Modulbus-Karten}
                          {Antwort als 16-Bit-Wert}
 ModAdr_Max        = $1F; {Erlaubte Anzahl von IO-Modul-Adressen}
 ModSub_Adr_ID     = $FE; {Hi-Byt: Card-ID         (LP), Lo-Byt: VG-ID = SlotID (VG)}
 ModSub_Adr_ModAdr = $FC; {Hi-Byt: Skalierung      (VG), Lo-Byt: Modul-Adr      (VG)}
 ModSub_Adr_EPLD   = $FA; {Hi-Byt: EPLD-ID         (LP), Lo-Byt: frei               }
 ModSub_Adr_Stat12 = $F8; {Hi-Byt: ModulStat Byte2 (LP), Lo-Byt:ModulStat Byte1 (LP)}
 ModSub_Adr_Stat34 = $F6; {Hi-Byt: ModulStat Byte4 (LP), Lo-Byt:ModulStat Byte3 (LP)}

 ModID_Schalt      = $1F; {FG 450.310 Schaltkarte                }
 ModID_Digital     = $20; {FG 450.320 Digital I/O                }
 ModID_Status      = $21; {FG 450.330 Status-Karte               }
 ModID_ADC         = $22; {FG 450.340 Analog I/O (+/-10V) mit Mux}
 ModID_12Event     = $23; {FG 450.350 12-fach Event-Generator    }

 Port_Stat      = $220;  {AT-Bus Port-Adressen}
 Port_Data      = $222;
 Port_Mode      = $224;
 Port_Rset      = $226;  {RÅcksetzen PC-MIL-Interface (Fifo, Timer usw.)  }
 Port_Intr      = $228;  {wichtig fÅr Ger"te-Simulation: Interrupts setzen}
 Port_Tmr1      = $22A;  {set and start timer1}
 Port_Tmr2      = $22C;  {set and start timer2}
 Port_Tmr2_1ms  = $22E;  {Umschalten Timer2: Data "0"=10us, Data "1"=1 ms}

 ifc_irmask_all = $E000; {Interrupt Enable Maske auf der IFC-Karte}
 ifc_irmask_intl= $8000;
 ifc_irmask_drdy= $4000;
 ifc_irmask_dreq= $2000;
 ifc_irmask_dis = $0000; {Interrupt Disable-All Maske auf der IFC-Karte}

 stat_intlock  = $0001;
 stat_dta_rdy  = $0002;
 stat_dta_req  = $0004;
 stat_wrt_rdy  = $0008;
 stat_val_wrd  = $0010;
 stat_ffo_ety  = $0020;
 stat_ffo_ful  = $0040;
 stat_cmd_mode = $0080;
 stat_cmd_rcv  = $0100;
 stat_timeout1 = $0200; { Bit 09 Hardware-Timer1: 0=laeuft, 1=abgelaufen  }
 stat_timeout2 = $0400; { Bit 10 Hardware-Timer2: 0=laeuft, 1=abgelaufen  }
 stat_timer2   = $0800; { Bit 11 Hardware-Timer2 Clock-Ticks: 0=10us 1=1ms}

 Taste_F1      = $3B; {Sondertasten liefern einen Doppelcode}
 Taste_F2      = $3C; {(2 x ReadKey): 1. Byte= #0     2. Byte= Tastenkode}
 Taste_F3      = $3D;
 Taste_F4      = $3E;
 Taste_F5      = $3F;
 Taste_F6      = $40;
 Taste_F7      = $41;
 Taste_F8      = $42;
 Taste_F9      = $43;
 Taste_F10     = $44;
 Taste_F11     = $85;
 Taste_F12     = $86;

 Taste_Pfeil_Links  = $4B;  {Vorsicht: NewReadKey benutzen}
 Taste_Pfeil_Rechts = $4D;
 Taste_Pfeil_Auf    = $48;
 Taste_Pfeil_Ab     = $50;
 Taste_Return       = #13;
 Taste_Esc          = $1B;

 Strich_Lot_Solid   = $B3;  {öbergr"·e fÅr Grafiken}
 Strich_Lot_Doted   = $7C;  { Write (chr(Strich_Lot_Doted)); }

                            {Cursor blinken lassen:  TextColor (Yellow+128)}
 Cursor_Solid       = $DB;  {Varianten B0, B1, B2}
                            { Write (chr(Cursor_Solid )); }

 ScanCode : Byte = 0;         {FÅr Extented Keyboard; Init auf 0}
 ScanData : Word = 0;

 Life_Time_Slow  = 5000;       {Anzeige-Dauer universales Lebenszeichen}
 Life_Time_Fast  = 2000;


type
 TMilErr   = (No_Err, Fc_To, Rd_To, Wr_To, Io_Adr, Io_AdrMode);
 TOnlineErr= (NoErr, WrTo, RdTo, AdrErr, ModAdrErr);   {Mod=Modulbus}

 TMode     = (Byt,Wrd);                          {fÅr einlesen von Hex-Werten}
 TFct    = record case Byte of
            1: (B: packed record
                    Adr : Byte;
                    Fct : Byte
                   end;
                );
            2: (W : Word);
             end;

 TFctAdr  = record
             Fct : Byte;
             Adr : Byte;
            end;
 Str4        = string[4];
 Num_Str     = string[10];
 TAsk_String = string[50];
 Str80       = string[80];

 T_Dual  = record
            Adr   : Byte;
            Fct   : Byte;
            Fct_Rd: Byte;
            Dta_ok: Boolean;
            Dta   : LongInt;
           end;

 TLife = (Norm, Blinc);
 TLife_XY = record
             Mode    : TLife;
             PosX    : Byte;
             PosY    : Byte;
             Time    : LongInt;
             Disp_Win: procedure;
            end;

var
 Ifc_Test_Nr: Byte;    {globale Nr. fÅr IFK-Tests}
 Mod_Test_Nr: Byte;    {globale Nr. fÅr Modul-Tests}
 Single_Step: Boolean; {globale Variable}

 IFK_Tab_Test_Nr: Byte;
 Dual      : array [1..2] of T_Dual;     {Globale Variable fÅr Mil_Dual_Mode}
 Ch        : Char;
 read_str  : str4;
 Transf_Cnt: LONGINT;

                 {Proceduren der Au·enwelt bekanntmachen}
procedure Menue_Base;
procedure Functioncode_Table;
procedure Displ_HS_Status;
procedure Displ_HS_Cmd;
procedure Displ_HS_Ctrl;
procedure convert_to_hex (in_string  : str4;
                           var hex_out: Word;
                           var status : boolean);

procedure Cursor(Sichtbar:Boolean);
procedure Displ_PC_Stat;
procedure Displ_Ifc_Stat;
procedure Ini_Text_Win;
procedure Set_Text_Win; far;
procedure Ini_Headl_Win;
procedure Ini_Msg_Win;
procedure Ini_Err_Win;
procedure Ini_Info_Win;
procedure Set_Color_Alarm;
procedure Set_Color_Norm;
procedure Std_Msg;
procedure Ini_Jumper_Win;

procedure Status_Tab1  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab2  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab3  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab4  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab5  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab6  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab7  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab8  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab9  (Spalte_Start, Zeile_Start: Byte);
procedure Status_TabA  (Spalte_Start, Zeile_Start: Byte);
procedure Status_TabB  (Spalte_Start, Zeile_Start: Byte);
procedure Status_TabC  (Spalte_Start, Zeile_Start: Byte);
procedure Status_TabD  (Spalte_Start, Zeile_Start: Byte);
procedure Status_TabE  (Spalte_Start, Zeile_Start: Byte);
procedure Status_TabF  (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab10 (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab11 (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab12 (Spalte_Start, Zeile_Start: Byte);
procedure Status_Tab13 (Spalte_Start, Zeile_Start: Byte);

function Ask_Data: Word;
function Hex_Word(w: Word): Num_Str;
function Hex_Byte(b: BYTE): Num_Str;
function Ask_Hex_Word: Word; {nicht fÅr Neuentwicklungen: besser Ask_Hex_Break}
function Ask_Hex_Byte: Byte; {nicht fÅr Neuentwicklungen: besser Ask_Hex_Break}
function Ask_Hex_Break (var In_Data: Word; Mode: TMode): Boolean; {Abort m. Esc}
function Ask_String_Break (Info_Str: TAsk_String; var In_Str: Str80): Boolean;
function KeyEPressed: Boolean;   {ben"tigt fÅr Funktionstasten F11, F12}
function NewReadKey: Char;       {ben"tigt fÅr Funktionstasten F11, F12}
function Read_Int (Min, Max: Integer; var Neu: Integer): Boolean;

{function Get_LastNr (var Num: Byte): Boolean; }

implementation                                    {Teil der UNIT-Deklaration}
  procedure Std_Msg;
   begin
    Ini_Msg_Win;
    Write('Stop/Single Step mit <SPACE>, Loop mit <CR> ,  Ende mit [X]');
   end;

         {Text an User wird als Info-String mit max. 50 Zeichen Åbergeben}
 function Ask_String_Break (Info_Str: TAsk_String; var In_Str: Str80): Boolean;
  var ZeichenZahl : Integer;
  begin
   Ask_String_Break := False;
   Ini_Msg_Win;
   Write (Info_Str); Write (' bzw. Abort <CR> : ');
   {$I-}                            {Compiler Check aus, Error selber abfangen}
   Readln (In_Str);
   {$I+}
   if IoResult = 0 then                             {PrÅfe, ob Eigabe ok}
    begin
     ZeichenZahl   := Byte(In_Str[0]);
     if ZeichenZahl > 0 then  Ask_String_Break := True;
    end;
  end; {Ask_String_Break}




function KeyEPressed: Boolean; assembler;
 asm
   mov ah, $11
   int 16h
   mov ax,1
   jnz @@True
   xor ax,ax
 @@True:
 end;

function ReadEKey: Word; assembler;
 asm
  mov ah,10h
  int 16h
 end;

function NewReadKey: Char;
 begin
   if ScanCode <> 0 then             {Gebe dem Anwender den Scancode}
    begin
      NewReadKey := Char(ScanCode);
      ScanCode := 0;
      exit;
    end;

   ScanData := ReadEKey;         {Einschlie·lich Make-Code E0 der Pfeiltasten}
   if( Lo(ScanData) = 0) or (Lo(ScanData) = $E0) then
    begin                             {Es ist ein ScanCode}
     ScanCode := Hi (ScanData);
     NewReadKey := #0;                {Anwender soll 2. Byte abholen}
     exit;
    end;
   NewReadKey := Char (Lo(ScanData)); {Es ist ein normales Zeichen}
 end;

 procedure Ini_Text_Win;
  begin
   Window(1, 3, 80, 24);
   TextBackground(White);
   TextColor(Black);               {Setze Schriftfarbe}
   ClrScr;
  end;

 procedure Ini_Jumper_Win;        {Nur fÅr Magnete}
  begin
   Window(02, 21, 79, 23);
   TextBackground(Blue);
   TextColor(Black);               {Setze Schriftfarbe}
   ClrScr;
  end;

 procedure Set_Jumper_Win;         {Nur fÅr Magnete}
  begin
   Window(02, 21, 79, 23);
   TextBackground(Black);
   TextColor(Black);               {Setze Schriftfarbe}
  end;

procedure Menue_Base;    {fester MenÅ-Teil: fÅr alle Programme gleich}
 begin
  Ini_Text_Win;
  GotoXY(5, 1);
  Writeln('*****************************  TEST-MENUE  ******************************');
  GotoXY(5, 2);
  Writeln('[A]<-- Welche IFK testen?                   Welche IFK am MIL-Bus? -->[0]');
  GotoXY(5, 3);
  Writeln('[B]<-- Lese IFK Status(C9)+Enabl-Intr    öberwache Online IFK (C9) -->[1]');
  GotoXY(5, 4);
  Writeln('[C]<-- Lese PC-Karte Status              Lese HS-CTRL-Reg (Fct=CA) -->[2]');
  GotoXY(5, 5);
  Writeln('[D]<-- Lese PC-Karte Daten RCV-Reg.        Lese HS-Status (Fct=CB) -->[3]');
  GotoXY(5, 6);
  Writeln('[E]<-* Lese IFK Daten (m. Fct-Code)        Lese IFK Status C0..C2  -->[4]');
  TextColor(Brown);               {Setze Schriftfarbe}
  GotoXY(5, 7);
  Writeln('[F]<-- Fct-Code- u. Piggy-ID Tabelle       Hex <--> Volt (+/-10V)  -->[5]');
  TextColor(Black);               {Setze Schriftfarbe}
  GotoXY(5, 8);
  Writeln('[G]<-- Sende Daten z. IFK ohne Fct-Code    Zeige Interrupt-Mask PC -->[6]');
  GotoXY(5, 9);
  Writeln('[H]<-- Sende Fct-Code zur IFK              Sende HS-Cmds+Disp-Stat -->[7]');
  GotoXY(5, 10);
  Writeln('[I]<-* Sende Daten zur IFK (m. Fct-Code)                              [8]');
  GotoXY(5, 11);
  Writeln('[J]<-* Sende/Lese User-Defin. Daten            Wr/Rd-Echo(0..FFFF) -->[9]');
  GotoXY(5, 12);
  Writeln('[K]<-- Sende/Lese Daten (0..FFFF)                        Modul-Bus -->[Y]');
  GotoXY(5, 13);
  Write  ('[L]<-- Sende 1/2 Fct-Codes an 1/2 IFK-Adr             ');
  TextColor(Brown); Write ('Telefonliste'); TextColor(Black); Write(' -->[Z]');
 end;

  function hex_byte(b: BYTE): Num_Str;
  const hex_num : STRING[16] = '0123456789ABCDEF';
  begin
   hex_byte := hex_num[(b shr 4) + 1] + hex_num[(b AND $0F) + 1];
  end;

 function hex_word (w: Word): Num_Str;
  begin
   hex_word := hex_byte(HI (w)) + hex_byte(LO (w));
  end; {hex_word}

 procedure Convert_To_Hex (in_string  : str4;
                           var hex_out: Word;
                           var status : boolean);
  var
   offset,i : INTEGER;
   dummy    : Word;
  begin
   offset := ORD('A') - ORD('a');
   status := TRUE;
   hex_out:= 0;
{   for i :=  1 TO 4 do  }
    for i :=  1 TO ord(In_String[0]) do    {In_String[0] = Anzahl Zeichen}
    begin
     if in_string[i] <> ' ' then
       begin
         if in_string[i] in ['a'..'f'] then
            in_string[i] := CHR(offset + ORD(in_string[i]));
         if in_string[i] in ['0'..'9'] then
          hex_out := hex_out * 16 + (ORD(in_string[i]) - ORD('0'))
         else
          begin
            if in_string[i] in ['A' ..'F'] then
              hex_out := hex_out * 16 + (ORD(in_string[i]) - ORD('A') + 10)
            else
             status := FALSE;
          end; {if in 0..9}
       end; {if<>blank}
    end; {for i}
  end;

FUNCTION Ask_Data: WORD;
 VAR in_data : WORD;
     Status : Boolean;
 Begin
  status := FALSE;
  WHILE NOT status DO
   Begin
    Ini_text_win;
    GotoXY(5, 22);
    write ('FÅr den MIL-Transfer-Test werden die WRITE-Daten ben"tigt!! ');
    ini_msg_win;
    write   ('--> Bitte 4-stellige Hex-Daten eingeben: '); readln(read_str);
    convert_to_hex (read_str,in_data,status);
    IF NOT status THEN
      Begin
       ini_err_win;
       writeln('ERROR: Sorry, USER: das war keine 4-stell. Hexzahl!!');
      End;
   End; {WHILE}
  ask_data := in_data;
 End; {Ask_Data}

               {*********** Routinen fÅr div. Fenster ***************}
{
   Farbnamen fÅr Fenster und Schrift:
   Black, Blue, Green, Cyan, Red, Magenta, Brown, Yellow, White, Blink
}
  procedure ini_headl_win;
   begin                             {Definitionen gelten bis neu definiert}
    Window(1, 1, 80, 2);             {Definiert ein Textfenster: Spalte/Zeile}
    TextBackground(Magenta);         {Setze Hintergrund fÅr Textfenster}
    TextColor(Yellow);               {Setze Schriftfarbe}
    ClrScr;                          {Clear Window}
    GotoXY(1, 1);                    {Cursor auf Anfang Fenster}
   end;


  procedure set_text_win;
   begin
    Window(1, 3, 80, 24);
    TextBackground(White);
    TextColor(Black);               {Setze Schriftfarbe}
   end;

  procedure ini_msg_win;
   begin
    Window(1, 25, 80, 25);
    TextBackground(Green);
    TextColor(Yellow);               {Setze Schriftfarbe}
    ClrScr;
   end;

  procedure ini_err_win;
   begin
    Window(1, 25, 80, 25);
    TextBackground(Green);
    TextColor(Red);               {Setze Schriftfarbe}
    ClrScr;
   end;

  procedure ini_info_win;
   begin
    Window(50, 11, 80, 22);
    TextBackground(Cyan);
    TextColor(Black);               {Setze Schriftfarbe}
    ClrScr;
   end;

  procedure Set_Color_Alarm;
   begin
    TextBackground(Red);
    TextColor(Yellow);
   end;

  procedure Set_Color_Norm;
   begin
    TextBackground(White);
    TextColor(Black);               {Setze Schriftfarbe}
   end;

 function ask_hex_byte: byte;
  var In_str : string[2];
      Status : boolean;
      Num    : byte;
      I      : word;
      Ch     : char;
  begin
   Status := FALSE;
   while not Status do
    begin
     ini_msg_win;
     write ('--> Bitte 2-stellige Hex-Daten eingeben: '); readln(In_str);
     if (In_str[1] in ['0'..'9','a'..'f','A'..'F']) and (In_str[2] in ['0'..'9','a'..'f','A'..'F']) then
            Status := TRUE;
     if not status then
      begin
       ini_err_win;
       write('ERROR: Sorry, USER: das war keine 2-stell. Hexzahl!! Weiter mit <Space>');
       Ch := NewReadKey ;
      end;
    end;  {while}

    for I := 1 to 2 do
     begin
      if In_str[I] in ['a'..'f'] then In_str[I] := upcase(In_str[I]);
      if In_str[I] in ['0'..'9'] then
       num := num*16 + (Ord(In_str[I]) - Ord('0'));
      if In_str[I] in ['A'..'F'] then
       num := num*16 + (Ord(In_str[I]) - Ord('A')+10);
     end;
    ask_hex_byte := num;
  end;

function Ask_Hex_Word: Word;
var Status  : Boolean;
    In_Data : Word;
    Read_Str: Str4;
begin
  status := False;
  while not status do
   begin
    ini_msg_win;
    write   ('--> Bitte 4-stellige Hex-Daten eingeben: '); readln(read_str);
    convert_to_hex (read_str,in_data,status);
    if not status then
     begin
      ini_err_win;
      write('ERROR: Sorry, USER: das war keine 4-stellige Hexzahl!  Weiter mit <CR>');
      NewReadKey;
     end;
   end; {while}
  Ask_Hex_Word := In_Data;
 end; {ask_hex_word}

 {ask_hex_break ist Einleseroutine fÅr Byte- und Word-Werte mit Abbruch durch
  Esc-Taste. Der Mode gibt an, ob Byte- oder Word-Daten gelesen werden}
 function Ask_Hex_Break (var In_Data: Word; Mode: TMode): Boolean;
  label 1;
  var Status  : Boolean;
      Read_Str: Str4;
      Zeichen : Char;
      N, I    : Byte;
      savex, savey : Byte;    {Rette Cursor-Position}
      Ziffer_Max : Byte;

  begin
    Ask_Hex_Break := False;
    if (Mode = Byt) then Ziffer_Max := 2 else Ziffer_Max := 4;
    Ini_Msg_Win;
    Write   ('--> Bitte ', Ziffer_Max, '-stellige Hex-Daten eingeben oder Abbruch mit <Esc>: ');

    for I := 1 to Ziffer_Max do Read_Str[I] := '_';
    if (Mode = Byt) then Read_Str[0] := #2 else Read_Str[0] := #4;
    SaveX := WhereX; SaveY := WhereY;

     N := 0;
     repeat
       Zeichen := NewReadKey;
       case Zeichen of
        '0'..'9','A'..'F','a'..'f' : begin
                                        if N < Ziffer_Max then N := N + 1;
                                        Read_Str[N]:= Zeichen;
                                        GotoXY (savex, savey);
                                        for I := 1 to N do Write (Read_Str[I]);
                                      end;
         chr($08)  {Esc-Taste}      : begin
                                        if (N > 0) and (Read_Str[N] in ['0'..'9','A'..'F','a'..'f']) then
                                         begin
                                           Read_Str[N]:= ' ';
                                           GotoXY (savex, savey);
                                           for I := 1 to N do Write (Read_Str[I]);
                                           N := N - 1;
                                         end;
                                       end;
         chr($1B)   {Return-Taste}  : begin
                                        Ini_Msg_Win;
                                        goto 1;
                                      end;
       end; {case}
     until Zeichen = chr($0D);
     if N = 0 then goto 1;

     Convert_To_Hex (Read_Str,In_Data,Status);
     if status then Ask_Hex_Break := True;
1:
  end; {Ask_Hex_Byte_Break}

 procedure Functioncode_Table;
  label 99;
  var Ch : Char;

  procedure Code_Table1;
   begin
    Ini_Text_Win;
            {[Dez]-[Hex]--Funktion---------------v     [Dez]-[Hex]--Funktion---------------v'}
    write ('    0     0   Keine Funktion               128    80   Daten lesen              ');
    write ('    1     1   Schalter auf Standby (Reset) 129    81   Istwert 1 lesen          ');
    write ('    2     2   Ger"t einschalten            130    82   Istwert 2 lesen          ');
    write ('    3     3   Ger"t ausschalten            131    83   Istwert 3 lesen          ');
    write ('    4     4   Polarit"t + setzen           132    84   Istwert 4 lesen          ');
    write ('    5     5   Polarit"t - setzen           133    85   Istwert 5 lesen          ');
    write ('    6     6   Sollwert  1 setzen           134    86   Istwert 6 lesen          ');
    write ('    7     7   Sollwert  2 setzen           135    87   Istwert 7 lesen          ');
    write ('    8     8   Sollwert  3 setzen           136    88   Istwert 8 lesen          ');
    write ('    9     9   Sollwert  4 setzen           137    89   Echo-Sollwert rÅcklesen  ');
    write ('   10     A   Sollwert  5 setzen           138    8A   frei                     ');
    write ('   11     B   Sollwert  6 setzen           139    8B   .                        ');
    write ('   12     C   Sollwert  7 setzen           140    8C   .                        ');
    write ('   13     D   Sollwert  8 setzen           141    8D   frei                     ');
    write ('   14     E   Wait                         142    8E   Piggy-Back Ident.        ');
    write ('   15     F   Release                      143    8F   Datenblock v. SD-uP lesen');
  end;

  procedure Code_Table2;
   begin
    Ini_Text_Win;
            {[Dez]-[Hex]--Funktion---------------v     [Dez]-[Hex]--Funktion---------------v'}
    write ('   16    10   Datenbus Setzen              144    90   Datenbus lesen           ');
    write ('   17    11   Adressbus setzen             145    91   Ger"tedaten 1 lesen      ');
    write ('   18    12   Set_INR_Maske                146    92   Ger"tedaten 2 lesen      ');
    write ('   19    13   Echo-Sollwert setzen         147    93   Ger"tedaten 3 lesen      ');
    write ('   20    14   Ger"tefunktion  1            148    94   Ger"tedaten 4 lesen      ');
    write ('    |     |         |         |            149    95   Ger"tedaten 5 lesen      ');
    write ('    |     |         |         |            150    96   Ger"tedaten 6 lesen      ');
    write ('   39    27   Ger"tefunktion 20            151    97   Ger"tedaten 7 lesen      ');
    write ('   40    28   Status 1 anfordern           152    98   Ger"tedaten 8 lesen      ');
    write ('   41    29   Status 2 anfordern           153    99   frei                     ');
    write ('   42    2A   Status 3 anfordern           .           .                        ');
    write ('   43    2B   SIS_12 Betrieb               .           .                        ');
    write ('   44    2C   SIS_18 Betrieb               .           .                        ');
    write ('   45    2D   Ger"tefunktion 21            .           .                        ');
    write ('    |     |         |         |            .           .                        ');
    write ('    |     |         |         |            .           .                        ');
    write ('   94    5E   Ger"tefunktion 70            .           .                        ');
    write ('   95    5F   frei                         .           .                        ');
    write ('    .         .                            .           .                        ');
    write ('    .         .                            .           .                        ');
    write ('   116   74   frei                         191    BF   frei                   ');
   end;

  procedure Code_Table3;
   begin
    Ini_Text_Win;
            {[Dez]-[Hex]--Funktion---------------v     [Dez]-[Hex]--Funktion---------------v'}
    write ('   117   75   Reset SEL-Error (auf Piggy)  192    C0   Status-Byte 1 lesen      ');
    write ('   118   76   Reset HI-Interlock Status    193    C1   Status-Byte 2 lesen      ');
    write ('   119   77   Reset HI-INL (vom Rechner)   194    C2   Status-Byte 3 lesen      ');
    write ('   120   78   Set   HI-INL (vom Rechner)   195    C3   frei                     ');
    write ('   121   79   Reset HI-INL Enable          .                                    ');
    write ('   122   7A   Set   HI-INL Enable          .           .                        ');
    write ('   123   7B   Reset HI-INL Gate            .           .                        ');
    write ('   124   7C   Set   HI-INL Gate            200    C8   frei                     ');
    write ('   125   7D   Reset RCV-Error (VW Test)    201    C9   * Interrupt-Maske  lesen ');
    write ('   126   7E   Reset Broadcast              202    CA   * Ctrl-Register    lesen ');
    write ('   127   7F   Set   Broadcast              203    CB   * Maske HI-Interl  lesen ');
    write ('                                           204    CC   * IFK-Identcode    lesen ');
    write ('----- Ende der Read-Functioncodes ------   205    CD   * IFK-EPLD-Version lesen ');
    write ('    [ab 128 (80 Hex) WRITE-Functions]      206    CE   frei                     ');
    write ('                                           .           .                        ');
    write ('                                           223    DF   frei                     ');
    write ('                                           224    E0   # Piggy Identcode lesen  ');
    write ('                                           225    E1   # Piggy EPLD-Vers.lesen  ');
    write ('  Legende:                                 226    E2   frei                     ');
    write ('  * Register auf der Interface-Karte       .           .                        ');
    write ('  # Register auf dem Piggy                 255    FF   frei                    ');
   end;

  procedure Code_Table4;
   begin
    Ini_Text_Win;
              {ID-Code[Hex]  IFK Version }
    writeln ('   FD          FG 450.012  IFK speziell fÅr Modulbus ');
  end;

  procedure Code_Table5;
   begin
    Ini_Text_Win;
              {ID-Code [Hex] Piggy Function'}
    writeln ('   01          FG 402.000  Serielles I/O V24            ');
    writeln ('   02          FG 402.000  Serielles I/O 20mA           ');
    writeln ('   03          FG 380.540  neuer Funktionsgenerator     ');
    writeln ('   04          FG 403.000  IEC-Bus Controller           ');
    writeln ('   05          FG 380.710  Strahldiagnose Blockmode     ');
    writeln ('   06          FG 380.720  Modulbus-Piggy fÅr FG 380.20x');
    writeln;
    writeln ('   08          FG 404.000  GSI85-Bus                    ');
    writeln;
    writeln ('   10          FG 443.000  VME-Bus                  ');
    writeln ('   20          FG 468.000  Flash                    ');
    writeln ('   40          FG 495.000  Ext. Event 6-fach        ');
   end;

 procedure Code_Table_Msg;
  begin
   Ini_Text_Win;
   Ini_Msg_Win;
   TextColor(red); Write ('Fortsetzung'); TextColor(Yellow);
   Write (' mit <Space>    oder    E[X]it ');
   Set_Text_Win;
  end;


  procedure Fct_Headline;
   begin
    Ini_Headl_Win;
    GotoXY(01,01);
    write('SCHREIBEN (SE->IFK)          Funktioncodes [13.07.1995]          LESEN (IFK->SE)');
    GotoXY(01,02);
    write(' [Dez]-[Hex]--Funktion---------------v    [Dez]-[Hex]--Funktion---------------v');
    Code_Table_Msg;
   end;

  procedure IFK_Headline;
   begin
    Ini_Headl_Win;
    GotoXY(01,01);
    write('                          IFK-Identifikation     [10.02.1997]                   ');
    GotoXY(01,02);
    write(' ID-Code[Hex]  IFK Version                         Lesen mit Fct-Code: CC [Hex]');
    Code_Table_Msg;
   end;


  procedure Pigy_Headline;
   begin
    Ini_Headl_Win;
    GotoXY(01,01);
    write('                          IFK: Piggy Ident-Codes [10.02.1997]                   ');
    GotoXY(01,02);
    write(' ID-Code[Hex]  Piggy Funktion                      Lesen mit Fct-Code: 8E [Hex]');
    Code_Table_Msg;
   end;

  begin
    Fct_Headline;
    Code_Table1;
    repeat until KeyEPressed;
    Ch := NewReadKey;
    if Ch in ['x','X']then Goto 99;

    Fct_Headline;
    Code_Table2;
    repeat until KeyEPressed;
    Ch := NewReadKey;
    if Ch in ['x','X']then Goto 99;

    Fct_Headline;
    Code_Table3;
    repeat until KeyEPressed;
    Ch := NewReadKey;
    if Ch in ['x','X']then Goto 99;

    IFK_Headline;
    Code_Table4;
    repeat until KeyEPressed;
    Ch := NewReadKey;
    if Ch in ['x','X']then Goto 99;

    Pigy_Headline;
    Code_Table5;
    repeat until KeyEPressed;
    Ch := NewReadKey;
    if Ch in ['x','X']then Goto 99;
99:
  end;


 PROCEDURE displ_pc_stat;
  Begin
     {Info-Anzeige der Bit-Belegung Hardware-Status}
      ini_info_win;
      writeln('Bit 11: Timer2: 0=10us  1=1ms');
      writeln('Bit 10: Timer2: Timeout      ');
      writeln('Bit 09: Timer1: Timeout      ');
      writeln('Bit 08: CMD/DATA receive     ');
      writeln('Bit 07: CMD/DATA transmit    ');
      writeln('Bit 06: Fifo full            ');
      writeln('Bit 05: Fifo empty           ');
      writeln('Bit 04: Valid Word           ');
      writeln('Bit 03: Ready for Write      ');
      writeln('Bit 02: Data Req             ');
      writeln('Bit 01: Data Ready           ');
      write  ('Bit 00: Interlock            ');
   End; {displ_dyn_stat_bits}

 PROCEDURE displ_ifc_stat;
  Begin
     {Info-Anzeige der Bit-Belegung IFC-Status}
      ini_info_win;
      writeln('Bit 15: Intrlck_Mask  1-Enable');
      writeln('Bit 14: Dta_Rdy_Mask  1-Enable');
      writeln('Bit 13: Dta_Req_Mask  1-Enable');
      writeln('Bit 12: Intrlck-Sign  0-aktiv ');
      writeln('Bit 11: Dta-Rdy-Sign  0-aktiv ');
      writeln('Bit 10: Dta-Req-Sign  0-aktiv ');
      writeln('Bit 09: frei                  ');
      writeln('Bit 08: frei                  ');
      writeln;
      writeln('Bit 07: A7 IFC-Adr            ');
      writeln(' "  |   |    "                ');
      write  ('Bit 00: A0 IFC-Adr            ');
   End; {displ_ifc_stat}

 PROCEDURE Displ_HS_Status;
  Begin
     {Info-Anzeige der Bit-Belegung Hochstrom-Maske}
      ini_info_win;
      writeln('Bit 15: HS Gate Enabl 0-Disabl');
      writeln('Bit 14: HS Enable     0-Disabl');
      writeln('Bit 13: HS v. Softw.  0-aktiv ');
      writeln('Bit 12: HS-SumIntl FF 0-aktiv ');
      writeln('Bit 11: HS-Sig live   0-aktiv ');
      writeln('Bit 10: HS-Sig FF     0-aktiv ');
      writeln('Bit 09: HS-Opto live  0-aktiv ');
      writeln('Bit 08: HS-Opto FF    0-aktiv ');
      writeln;
      writeln('Bit 07: A7 IFC-Adr            ');
      writeln(' "  |   |    "                ');
      write  ('Bit 00: A0 IFC-Adr            ');
   End; {displ_HS_Status}

 PROCEDURE Displ_HS_Cmd;
  Begin
     {Info-Anzeige der Bit-Belegung Hochstrom-Maske}
      Set_Text_Win;
      Window(01, 11, 35, 22);
      TextBackground(Cyan);
      TextColor(Black);               {Setze Schriftfarbe}
      ClrScr;
      writeln('7F H : Set   Broadcast           ');
      writeln('7E H : Reset Broadcast           ');
      writeln('7D H : Reset RCV-Error (Val Word)');
      writeln('  ');
      writeln('  ');
      writeln('7C H : Enable  HS-INL    Gate    ');
      writeln('7B H : Disable HS-INL    Gate    ');
      writeln('7A H : Enable  HS-INL            ');
      writeln('79 H : Disable HS-INL            ');
      writeln('78 H : Set     HS-INL v. Rechner ');
      writeln('77 H : Reset   HS-INL v. Rechner ');
      write  ('76 H : Reset   HS-INL    Status  ');
   End; {Displ_HS_Cmd}


 PROCEDURE Displ_HS_Ctrl;
  Begin
     {Info-Anzeige der Bit-Belegung Hochstrom-Maske}
      ini_info_win;
      writeln('Bit 15: MIL-Spg. 15V  1-aktiv');
      writeln('Bit 14: Sel Err Pigy  1-aktiv');
      writeln('Bit   :                      ');
      writeln('Bit   :                      ');
      writeln('Bit   :                      ');
      writeln('Bit   :                      ');
      writeln('Bit 09: Broadcast     1-aktiv');
      writeln('Bit 08: Receive Error 1-aktiv');
      writeln;
      writeln('Bit 07: A7 IFC-Adr            ');
      writeln(' "  |   |    "                ');
      write  ('Bit 00: A0 IFC-Adr            ');
  End; {displ_HS_Ctrl}

   procedure Ini_Stat_Win;
   begin                             {Definitionen gelten bis neu definiert}
    Window(1, 1, 80, 2);             {Definiert ein Textfenster: Spalte/Zeile}
    TextBackground(Magenta);         {Setze Hintergrund fÅr Textfenster}
    TextColor(Yellow);               {Setze Schriftfarbe}
    ClrScr;                          {Clear Window}
    GotoXY(1, 1);                    {Cursor auf Anfang Fenster}
   end;

  const IFC_Color = White;

  procedure Status_Tab1 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '              Tabelle[1]: SIS-Magnete SVE        Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';

   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00  Ger"t AUS         3A  Byte C0H       16  xx Hand (local)  22A  Byte C2H');
    Writeln ('    01  xy Unterspg Phas  3C                 17  y StraSchuIntrl  22C         ');
    Writeln ('    02  xy Temp. NG       4A                 18  Last1 Aus        23A         ');
    Writeln ('    03  xy KÅhlwasser NG  4C                 19  Last2 Aus        23C         ');
    Writeln ('    04  xy öberstrom      5A                 20  Last3 Aus        24A         ');
    Writeln ('    05  Polarit"t minus   5C                 21  Last4 Aus        24C         ');
    Writeln ('    06  xy Temp. Last     6A                 22  Last5 Aus        25A         ');
    Writeln ('    07  xy H2O-Last       6C                 23  Reserve (High)   25C         ');
    Writeln;
    Writeln ('    08  y Prim"rstr > Ip 26A  Byte C1H                                        ');
    Writeln ('    09  y Prim"rstr >Ip1 26C                                                  ');
    Writeln ('    10  y TransiFehlV1-4 27A                                                  ');
    Writeln ('    11  y TransiFehl  V5 27C                                                  ');
    Writeln ('    12  y Gleichspg Ud1  28A                                                  ');
    Writeln ('    13  y Hilfs UB0 Fehl 28C                                                  ');
    Writeln ('    14  y DCCT Fehl Holc 29A                                                  ');
    Writeln ('    15  y Erdschlu·      29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_Tab2 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '            Tabelle[2]: Tekelec-EH-Umlenker      Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  xx Hand          22A  Byte C2H');
    Writeln ('    01 xy Unterspng Netz  3C                 17  High             22C         ');
    Writeln ('    02 xy Temp.  NG Trafo 4A                 18  Last1 Aus        23A         ');
    Writeln ('    03 xy Wasser NG       4C                 19  Last2 Aus        23C         ');
    Writeln ('    04 xy öberstrom I >   5A                 20  Last3 Aus        24A         ');
    Writeln ('    05    Reserve (High)  5C                 21  Last4 Aus        24C         ');
    Writeln ('    06 xy Temp.  Last     6A                 22  Last5 Aus        25A         ');
    Writeln ('    07 xy H2O     "       6C                 23  Reserve (High)   25C         ');
    Writeln;
    Writeln ('    08 y ö-Strom Prim Ip 26A  Byte C1H                                        ');
    Writeln ('    09 y Reserve (High)  26C                                                  ');
    Writeln ('    10 y TransiFehl T1-4 27A                                                  ');
    Writeln ('    11 y Reserve (High)  27C                                                  ');
    Writeln ('    12 y Temp Transistr  28A                                                  ');
    Writeln ('    13 y Temp Gleichrich 28C                                                  ');
    Writeln ('    14 y Sicherung Kond  29A                                                  ');
    Writeln ('    15 y Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_Tab3 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '         Tabelle[3]: Tekelec-Netzger"te LSB4     Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  xx Hand          22A  Byte C2H');
    Writeln ('    01 xy Unterspannung   3C                 17  High             22C         ');
    Writeln ('    02 xy Temp.  NG Trafo 4A                 18  Last1 Aus        23A         ');
    Writeln ('    03 xy Wasser NG       4C                 19  (Last2 Aus)      23C         ');
    Writeln ('    04 xy öberstrom I >   5A                 20  (Last3 Aus)      24A         ');
    Writeln ('    05    Reserve (High)  5C                 21  (Last4 Aus)      24C         ');
    Writeln ('    06 xy Temp.  Last     6A                 22  (Last5 Aus)      25A         ');
    Writeln ('    07 xy H2O      "      6C                 23  Reserve (High)   25C         ');
    Writeln;
    Writeln ('    08 y Reserve (High)  26A  Byte C1H                                        ');
    Writeln ('    09 y ö-Strom Pri Ip1 26C                                                  ');
    Writeln ('    10 y Trans Fehl T1-4 27A                                                  ');
    Writeln ('    11 y Reserve (High)  27C                                                  ');
    Writeln ('    12 y Temp Transistr  28A                                                  ');
    Writeln ('    13 y Temp Gleichrich 28C                                                  ');
    Writeln ('    14 y Reserve (High)  29A                                                  ');
    Writeln ('    15 y Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_Tab4 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '          Tabelle[4]: Danfysik-Netzger"te EH     Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  xx Hand          22A  Byte C2H');
    Writeln ('    01 xy Unterspannung   3C                 17  High             22C         ');
    Writeln ('    02 xy Temp.   NG      4A                 18  Last1 Aus        23A         ');
    Writeln ('    03 xy Wasser  NG      4C                 19  Last2 Aus        23C         ');
    Writeln ('    04 xy öberstrom I >   5A                 20  Last3 Aus        24A         ');
    Writeln ('    05    Reserve (High)  5C                 21  Last4 Aus        24C         ');
    Writeln ('    06 xy Temp.  Last     6A                 22  Last5 Aus        25A         ');
    Writeln ('    07 xy H2O     "       6C                 23  Reserve (High)   25C         ');
    Writeln;
    Writeln ('    08 y ö-Strom Prim Ip 26A  Byte C1H                                        ');
    Writeln ('    09 y Reserve (High)  26C                                                  ');
    Writeln ('    10 y TransiFehl T1-4 27A                                                  ');
    Writeln ('    11 y Reserve (High)  27C                                                  ');
    Writeln ('    12 y (Temp Trnsistr) 28A                                                  ');
    Writeln ('    13 y Mitnahme (St"rg)28C                                                  ');
    Writeln ('    14 y Reserve (High)  29A                                                  ');
    Writeln ('    15 y Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_Tab5 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '           Tabelle[5]: SVE 1 - SIS               Stand: 26.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A Byte C0H       16 y Laufz-Last-Tren  22A Byte C2H');
    Writeln ('    01 y 0 =Last-Trenn zu 3C                17 y GS - Drosseln    22C        ');
    Writeln ('    02 y SIS - 12 Aus     4A                18 y Magkabl Temp+H2O 23A        ');
    Writeln ('    03 y SIS - 18 Aus     4C                19 y Magnete Temp+H2O 23C        ');
    Writeln ('    04 y Hand             5A                20 y 20 KV Filter     24A        ');
    Writeln ('    05   Nicht betrbereit 5C                21 y 24 V und U <     24C        ');
    Writeln ('    06 y öberstrom I >    6A                22   60 V und U <     25A        ');
    Writeln ('    07 y öberstrom I >>   6C                23 y Erd/TempTraf/Gas 25C        ');
    Writeln;
    Writeln ('    08 y Trafo Fehler    26A  Byte C1H                                        ');
    Writeln ('    09   Mitn.Qkupl 20kV 26C                                                  ');
    Writeln ('    10 y Not - Aus       27A                                                  ');
    Writeln ('    11   Hilfenerg. Rglg 27C                                                  ');
    Writeln ('    12 y Stromricht Rglg 28A                                                  ');
    Writeln ('    13 y Stromri. Leistg 28C                                                  ');
    Writeln ('    14 y Paralell Einspg 29A                                                  ');
    Writeln ('    15 y PE KÅhlung      29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_Tab6 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '          Tabelle[6]: SVE 2 - SIS                Stand: 26.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A Byte C0H       16 y Laufz-Last-Tren  22A Byte C2H');
    Writeln ('    01 y 0 =Last-Trenn zu 3C                17 y GS - Drosseln    22C        ');
    Writeln ('    02   Reserve (High)   4A                18 y Magkabl Temp+H2O 23A        ');
    Writeln ('    03   Reserve (High)   4C                19 y Magnete Temp+H2O 23C        ');
    Writeln ('    04 y Hand             5A                20 y 20 KV Filter     24A        ');
    Writeln ('    05   Nicht betrbereit 5C                21 y 24 V und U <     24C        ');
    Writeln ('    06 y öberstrom I >    6A                22   60 V und U <     25A        ');
    Writeln ('    07 y öberstrom I >>   6C                23 y Erd/TempTraf/Gas 25C        ');
    Writeln;
    Writeln ('    08 y Trafo Fehler    26A  Byte C1H                                        ');
    Writeln ('    09   Mitn.Qkupl 20kV 26C                                                  ');
    Writeln ('    10 y Not - Aus       27A                                                  ');
    Writeln ('    11   Hilfenerg. Rglg 27C                                                  ');
    Writeln ('    12 y Stromricht Rglg 28A                                                  ');
    Writeln ('    13 y Stromri. Leistg 28C                                                  ');
    Writeln ('    14 y Paralell Einspg 29A                                                  ');
    Writeln ('    15 y PE KÅhlung      29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Status_Tab7 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '     Tabelle[7]: SVE 1 - ESR  2 - ESR  3 - ESR   Stand: 26.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A Byte C0H       16 y Laufz-Last-Tren  22A Byte C2H');
    Writeln ('    01 y 0 =Last-Trenn zu 3C                17 y GS - Drosseln    22C        ');
    Writeln ('    02   Reserve (High)   4A                18 y Magkabl Temp+H2O 23A        ');
    Writeln ('    03   Reserve (High)   4C                19 y Magnete Temp+H2O 23C        ');
    Writeln ('    04 y Hand             5A                20 y 20 KV Filter     24A        ');
    Writeln ('    05   Nicht betrbereit 5C                21 y 24 V und U <     24C        ');
    Writeln ('    06 y öberstrom I >    6A                22   60 V und U <     25A        ');
    Writeln ('    07 y öberstrom I >>   6C                23 y Erd/TempTraf/Gas 25C        ');
    Writeln;
    Writeln ('    08 y Trafo Fehler    26A  Byte C1H                                        ');
    Writeln ('    09   Mitn.Qkupl 20kV 26C                                                  ');
    Writeln ('    10 y Not - Aus       27A                                                  ');
    Writeln ('    11   Hilfenerg. Rglg 27C                                                  ');
    Writeln ('    12 y Stromricht Rglg 28A                                                  ');
    Writeln ('    13 y Stromri. Leistg 28C                                                  ');
    Writeln ('    14 y Paralell Einspg 29A                                                  ');
    Writeln ('    15 y PE KÅhlung      29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Status_Tab8 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '  Tabelle[8]: SVE 5 -, 6 -, 7 -, 10 -, 12 - ESR  Stand: 26.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  Hand            22A  Byte C2H');
    Writeln ('    01 y Phase            3C                 17  Reserve (High)  22C         ');
    Writeln ('    02 y SVE Temperatur   4A                 18  Reserve (High)  23A         ');
    Writeln ('    03 y SVE Wasser       4C                 19  Reserve (High)  23C         ');
    Writeln ('    04 y öberstrom I >    5A                 20  Reserve (High)  24A         ');
    Writeln ('    05   Reserve (High)   5C                 21  Reserve (High)  24C         ');
    Writeln ('    06 y Temp.  Magnet    6A                 22  Reserve (High)  25A         ');
    Writeln ('    07 y Wasser   "       6C                 23  Reserve (High)  25C         ');
    Writeln;
    Writeln ('    08 y I prim"r        26A  Byte C1H                                        ');
    Writeln ('    09   Reserve (High)  26C                                                  ');
    Writeln ('    10 y Transistor Bank 27A                                                  ');
    Writeln ('    11   Reserve (High)  27C                                                  ');
    Writeln ('    12   Reserve (High)  28A                                                  ');
    Writeln ('    13   Reserve (High)  28C                                                  ');
    Writeln ('    14 y DCCT sat.       29A                                                  ');
    Writeln ('    15 y Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Status_Tab9 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '          Tabelle[9]: SVE 4 - 9  ESR             Stand: 26.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  Hand            22A  Byte C2H');
    Writeln ('    01 y Phase            3C                 17  Reserve (High)  22C          ');
    Writeln ('    02 y SVE Temperatur   4A                 18  Reserve (High)  23A          ');
    Writeln ('    03 y SVE Wasser       4C                 19  Reserve (High)  23C          ');
    Writeln ('    04 y öberstrom I >    5A                 20  Reserve (High)  24A          ');
    Writeln ('    05 y Reserve (High)   5C                 21  Reserve (High)  24C          ');
    Writeln ('    06 y Temp. Magnet     6A                 22  Reserve (High)  25A          ');
    Writeln ('    07 y Wasser    "      6C                 23  Reserve (High)  25C          ');
    Writeln;
    Writeln ('    08 y öberstrom IP    26A  Byte C1H                                        ');
    Writeln ('    09 y öberstrom IP1   26C                                                  ');
    Writeln ('    10 y TransiFehlrT1-4 27A                                                  ');
    Writeln ('    11 y TransiFehler T5 27C                                                  ');
    Writeln ('    12 y Ud1 > Kond.bank 28A                                                  ');
    Writeln ('    13 y UB0 < Vers.Anst 28C                                                  ');
    Writeln ('    14 y DCCT sat. I >   29A                                                  ');
    Writeln ('    15 y Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Status_TabA (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '           Tabelle[A]: SVE 2 - H   3 - H         Stand: 26.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  Hand            22A  Byte C2H');
    Writeln ('    01 y Phase            3C                 17  Reserve (High)  22C          ');
    Writeln ('    02 y SVE Temperatur   4A                 18  Reserve (High)  23A          ');
    Writeln ('    03 y SVE Wasser       4C                 19  Reserve (High)  23C          ');
    Writeln ('    04 y öberstrom I >    5A                 20  Reserve (High)  24A          ');
    Writeln ('    05 y Polarit"t        5C                 21  Reserve (High)  24C          ');
    Writeln ('    06 y Temp Magnet/Kabl 6A                 22  Reserve (High)  25A          ');
    Writeln ('    07 y Wasser    "      6C                 23  Reserve (High)  25C          ');
    Writeln;
    Writeln ('    08 y Trafo I>Dreieck 26A  Byte C1H                                        ');
    Writeln ('    09 y Trafo I > Stern 26C                                                  ');
    Writeln ('    10 y Thyristor Si    27A                                                  ');
    Writeln ('    11 y Leistgschalt I> 27C                                                  ');
    Writeln ('    12 y Passivfilter    28A                                                  ');
    Writeln ('    13 y TÅrkontakt      28C                                                  ');
    Writeln ('    14 y DCCT sat.       29A                                                  ');
    Writeln ('    15 y Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Status_TabB (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '           Tabelle[B]: SVE-Brucker m. Einschub   Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  y Hand          22A  Byte C2H');
    Writeln ('    01 x U-Spg. PhasFehlr 3C                 17  Reserve (High)  22C          ');
    Writeln ('    02 x Temperatur NG    4A                 18  Last1   (High)  23A          ');
    Writeln ('    03 x Wasser     NG    4C                 19  Last2 Aus(offen)23C          ');
    Writeln ('    04 x öberstrom        5A                 20  Last3 Aus(offen)24A          ');
    Writeln ('    05 x Polwender Minus  5C                 21  Last4 Aus(offen)24C          ');
    Writeln ('    06 x Temp.  Last      6A                 22  Last5 Aus(offen)25A          ');
    Writeln ('    07 x Wasser Last      6C                 23  Reserve (High)  25C          ');
    Writeln;
    Writeln ('    08   Reserve (High)  26A  Byte C1H                                        ');
    Writeln ('    09   Reserve (High)  26C                                                  ');
    Writeln ('    10   Reserve (High)  27A                                                  ');
    Writeln ('    11   Reserve (High)  27C                                                  ');
    Writeln ('    12   Reserve (High)  28A                                                  ');
    Writeln ('    13   Reserve (High)  28C                                                  ');
    Writeln ('    14   Reserve (High)  29A                                                  ');
    Writeln ('    15   Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Status_TabC (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '           Tabelle[C]: SVE-Brucker 8-Bit-Status  Stand: 25.11.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H                                         ');
    Writeln ('    01 x U-Spg. PhasFehlr 3C                                                  ');
    Writeln ('    02 x Temperatur NG    4A                                                  ');
    Writeln ('    03 x Wasser     NG    4C                                                  ');
    Writeln ('    04 x öberstrom        5A                                                  ');
    Writeln ('    05 x Polwender Minus  5C                                                  ');
    Writeln ('    06 x Temp.  Last      6A                                                  ');
    Writeln ('    07 x Wasser Last      6C                                                  ');
    Writeln;
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;


 procedure Status_TabD (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '           Tabelle[D]: EZR-MV                    Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  y Hand          22A  Byte C2H');
    Writeln ('    01 x Ext. Fehler Mem. 3C                 17  Reserve (High)  22C          ');
    Writeln ('    02 x Ext. Fehler      4A                 18  HF aus          23A          ');
    Writeln ('    03 x Ausfall KÅhlung  4C                 19  frei (offen)    23C          ');
    Writeln ('    04 x I Anode zu gro·  5A                 20  frei (offen)    24A          ');
    Writeln ('    05 x ARC (Lichtbogen) 5C                 21  frei (offen)    24C          ');
    Writeln ('    06 x PrÅck  >         6A                 22  frei (offen)    25A          ');
    Writeln ('    07 x TÅr offen        6C                 23  Reserve (High)  25C          ');
    Writeln;
    Writeln ('    08   I FehlerSteuerg 26A  Byte C1H                                        ');
    Writeln ('    09   T zu kalt Fila  26C                                                  ');
    Writeln ('    10   Delta Hochspg.  27A                                                  ');
    Writeln ('    11   Reserve (High)  27C                                                  ');
    Writeln ('    12   Modus Vorheizen 28A                                                  ');
    Writeln ('    13   nicht bereit    28C                                                  ');
    Writeln ('    14   Local 2         29A                                                  ');
    Writeln ('    15   Body Current    29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_TabE (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '               Tabelle[E]: Hochspannung          Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY (Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  xx Hand (local)  22A  Byte C2H');
    Writeln ('    01   x Unterspannung  3C                 17  StraSchuIntrl    22C         ');
    Writeln ('    02   x Ext. Interlock 4A                 18  Last1 Aus (High) 23A (no IBegr');
    Writeln ('    03   x Temperatur     4C                 19  Last2 Aus (offen)23C (no UBegr');
    Writeln ('    04   x HV-Kammern Aus 5A                 20  Last3 Aus (offen)24A         ');
    Writeln ('    05   Polarit"t minus  5C                 21  Last4 Aus (offen)24C         ');
    Writeln ('    06   x HV-Interlock   6A                 22  Last5 Aus (offen)25A         ');
    Writeln ('    07   x Reserve (High) 6C                 23  Reserve (High)   25C         ');
    Writeln;
    Writeln ('    08   Spannungsmode   26A  Byte C1H                                        ');
    Writeln ('    09   Strommode       26C                                                  ');
    Writeln ('    10   Standby Lstg.aus27A                                                  ');
    Writeln ('    11   HV 50%          27C                                                  ');
    Writeln ('    12   Reserve (High)  28A                                                  ');
    Writeln ('    13   Reserve (High)  28C                                                  ');
    Writeln ('    14   Reserve (High)  29A                                                  ');
    Writeln ('    15   Reserve (High)  29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_TabF (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '               Tabelle[F]: HF: SIS + ESR         Stand: 21.11.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY (Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16 xx Kavit"t H2O    22A  Byte C2H');
    Writeln ('    01   xy Hand (local)  3C                 17 y  "    LÅfter    22C         ');
    Writeln ('    02   xy intern H2O    4A                 18 y  "    Temp. H2O 23A         ');
    Writeln ('    03   xy extern H2O    4C                 19 y  " öberschl GAP 23C         ');
    Writeln ('    04   xy Temp. Luft    5A                 20 y  " Schlu·   GAP 24A         ');
    Writeln ('    05   xy Phase Netz    5C                 21 y  " Vakuum       24C         ');
    Writeln ('    06   xy I  >  Netz    6A                 22 y Reserve (High)  25A         ');
    Writeln ('    07   xy Netzg TÅr+Not 6C                 23 y Kavit"t TÅr+Not 25C         ');
    Writeln;
    Writeln ('    08   y Endstufe H2O  26A  Byte C1H                                        ');
    Writeln ('    09   y  "     LÅfter 26C                                                  ');
    Writeln ('    10   y  " Temp. H2O  27A                                                  ');
    Writeln ('    11   y  " Manometer  27C                                                  ');
    Writeln ('    12   y  " HV-Stecker 28A                                                  ');
    Writeln ('    13   y  " IgnitrZÅnd 28C                                                  ');
    Writeln ('    14   y Reserve (High)29A                                                  ');
    Writeln ('    15   y Endst TÅr+Not 29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;


  procedure Status_Tab10 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '     Tabelle[10]: 8-Bit-Status o. Schaltkarte    Stand: 24.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY (Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H                                         ');
    Writeln ('    01   Hand (local)     3C                                                  ');
    Writeln ('    02   n. Schnittstplan 4A                                                  ');
    Writeln ('    03        "           4C                                                  ');
    Writeln ('    04        "           5A                                                 ');
    Writeln ('    05        "           5C                                                 ');
    Writeln ('    06        "           6A                                                 ');
    Writeln ('    07        "           6C                                                 ');
    Writeln;
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln (' ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_Tab11 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '     Tabelle[11]: Phasensonden (DPX)             Stand: 12.12.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY (Spalte_Start+01, Zeile_Start);
    Writeln ('   00  Powr Verst"rk Aus 3A  Byte C0H                                         ');
    Writeln ('    01  Powr Sumierer Aus 3C                                                  ');
    Writeln ('    02  Powr Multiplx Aus 4A                                                  ');
    Writeln ('    03  Blendanschl Nicht 4C                                                  ');
    Writeln ('    04  Bedien Blend Hand 5A                                                 ');
    Writeln ('    05  Tunnelkarte Nicht 5C                                                 ');
    Writeln ('    06  LSB-Karte   Nicht 6A                                                 ');
    Writeln ('    07  Reserve           6C                                                 ');
    Writeln;
    Writeln ('  ');
    Writeln ('  ');
    Writeln ('  ');
    Writeln ('  ');
    Writeln ('  ');
    Writeln ('  ');
    Writeln ('  ');
    Writeln ('  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

  procedure Status_Tab12 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '     Tabelle[12]: SIS-Magnet S11MU3R (J"ger)     Stand: 25.02.97' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';

   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00     Ger"t AUS      3A  Byte C0H       16  xx Hand (local)  22A  Byte C2H');
    Writeln ('    01  xy Unterspg Phas  3C                 17  y Einsperre 1min 22C         ');
    Writeln ('    02  xy Temp. NG       4A                 18  öStrom TransBank 23A         ');
    Writeln ('    03  xy KÅhlwasser NG  4C                 19  SchutzÅnd V8-V16 23C         ');
    Writeln ('    04  xy öberstrom Sek. 5A                 20  öSpg LinearBank  24A         ');
    Writeln ('    05     öStrom Prim 2  5C                 21  TrFehl V5/LinBank24C         ');
    Writeln ('    06  xy Temp. Last     6A                 22  DCCT T11 I ges"tt25A         ');
    Writeln ('    07  xy H2O-Last       6C                 23  Erdschl. Warnung 25C         ');
    Writeln;
    Writeln ('    08  y öSpannung Ud1  26A  Byte C1H                                        ');
    Writeln ('    09  y öSpannung Uc   26C                                                  ');
    Writeln ('    10  y Sicherung F22  27A                                                  ');
    Writeln ('    11  y Sicherung F21  27C                                                  ');
    Writeln ('    12  y TransistorV1-V428A                                                  ');
    Writeln ('    13  y DCCT T9 Iges"t 28C                                                  ');
    Writeln ('    14  y Delta Uc >Puls 29A                                                  ');
    Writeln ('    15  y C7 ZwangsEntldg29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Status_Tab13 (Spalte_Start, Zeile_Start: Byte);
  const
   Stat_Line1 =
     '      Tabelle[13]: SIS + ESR mit DAC (F"ldi)     Stand: 26.09.96' +
     '0/1 Bit Bedeutung        Pin  Bemerkng   0/1 Bit Bedeutung        Pin  Bemerkng';
   begin
    Ini_Stat_Win;
    GotoXY(1, 1);
    Write ('Ifc-Adr[Hex]: '); TextColor(IFC_Color); Write(hex_byte(Ifc_Test_Nr));
    TextColor(Yellow);

    Write(Stat_Line1);
    Ini_Text_Win;
    GotoXY(Spalte_Start+01, Zeile_Start);
    Writeln ('   00   Ger"t AUS        3A  Byte C0H       16  Hand            22A  Byte C2H');
    Writeln ('    01 y Phase            3C                 17  Reserve (High)  22C         ');
    Writeln ('    02 y SVE Temperatur   4A                 18  Reserve (High)  23A         ');
    Writeln ('    03 y SVE Wasser       4C                 19  Reserve (High)  23C         ');
    Writeln ('    04 y öberstrom I >    5A                 20  Reserve (High)  24A         ');
    Writeln ('    05   Polwender Minus  5C                 21  Reserve (High)  24C         ');
    Writeln ('    06 y Temp.  Magnet    6A                 22  Reserve (High)  25A         ');
    Writeln ('    07 y Wasser   "       6C                 23  Reserve (High)  25C         ');
    Writeln;
    Writeln ('    08 y I prim"r        26A  Byte C1H                                        ');
    Writeln ('    09   Reserve (High)  26C                                                  ');
    Writeln ('    10 y Transistor Bank 27A                                                  ');
    Writeln ('    11   Reserve (High)  27C                                                  ');
    Writeln ('    12   Reserve (High)  28A                                                  ');
    Writeln ('    13   Reserve (High)  28C                                                  ');
    Writeln ('    14 y DCCT sat.       29A                                                  ');
    Writeln ('    15 y Erdschlu·       29C                                                  ');
    Writeln;
    Ini_Jumper_Win;
    TextColor(Yellow);
    Writeln ('Text bzw. Fehler entspricht Nullbezug!! 0 = Fehler, 1 = o. k., F = Lesefehler');
    Writeln ('Alle Eing"nge Pulldown!! x  = Summen-Interlock (x + xx: Schaltkarte gebildet)');
    TextColor(White);
    Write ('Loop:'); TextColor(Yellow);
    Write   ('                    xx = Sum-Intl-Opt, falls Jumpr unten, y=Ger"t gebild');
    Set_Text_Win;
    GotoXY(01,22);
    TextColor(Brown);
    Write (' Rd_Err:        SW[H]:     SW[V]:            SW[A]:            SW[Amax]:       ');
    TextColor(Black);
   end;

 procedure Cursor(Sichtbar:Boolean);
 var
   schirmanfang : LongInt;
   reg:Registers;

   procedure Karte;           {Stelle Kartentyp fest}
   var
     Treiber,Modus:Integer;
   begin
     Treiber:=Detect;
     DetectGraph(Treiber,Modus);
     case Treiber of
       1..6,8..9 : Schirmanfang:=$b800;
       -2,7,10   : Schirmanfang:=$b000;
     end;
   end;

 begin {Cursor}
   reg.ah:=1;
   if sichtbar then
   begin
     if schirmanfang=$b800 then begin
       reg.ch:=6;
       reg.cl:=7;
     end
    else
     begin
       reg.ch:=12;
       reg.cl:=13;
     end;
     Intr(16,reg);
   end
  else
   begin
     reg.ch:=32;
     reg.cl:=7;
     Intr(16,reg);
   end;
 end;

  {Falls Min u. Max = 0: Standard Integer-Werte: -32768 .. + 32767}
function Read_Int (Min, Max: Integer; var Neu: Integer): Boolean;
 label 1;
 var User_Int: LongInt;
     IoRes   : Integer;
     Answer  : Char;

 begin
   Read_Int := False;
   if ((Min = 0) and (Max = 0)) then
   begin
    Min := -32768;
    Max := +32767;
   end;
   repeat
     Ini_Msg_Win;
     Write ('Bitte Integer (ganze Zahl) im Bereich [',Min,'..',Max,'] eingeben oder [Q]uit: ');
     {$I-}                            {Compiler Check aus, Error selber abfangen}
     Read (User_Int);
     {$I+}
     IoRes := IoResult;
     if not ((Min <= User_Int) and (User_Int <= Max) and (IoRes = 0)) then
      begin
        Ini_Err_Win;
        Write ('ERROR: Eingabe nicht korrekt!!     Abort mit <Esc> oder wiederholen mit <CR>: ');
        Answer := ReadKey;
        if Answer = #27 then
         begin
          Ini_Msg_Win;
          Write ('Abort ');
          goto 1;
         end;
      end;
   until (Min <= User_Int) and (User_Int <= Max) and (IoRes = 0);
   Read_Int := True;
   Neu := User_Int;
1: Set_Text_Win;
 end; {Read_Int}
end.  { UNIT DATECH_1 }


