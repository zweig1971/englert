{
 ---------------------------------------------------------------------
 File - mydriver_lib.pas
 
 Library for accessing the MYDRIVER card,
 Code was generated by Driver Wizard.
 It accesses the hardware via WinDriver functions.
 ---------------------------------------------------------------------
}

unit mydriver_lib;

interface

uses 
    Windows,
    SysUtils,
    WinDrvr,
    PCI_Regs,
    Windrvr_Int_Thread,
    Bits;

var
    MYDRIVER_ErrorString : String;        { this STRING is set to an error message, if one occurs }

{ internal data structures }
type MYDRIVER_INT_RESULT = record 
    dwCounter : DWORD;   { number of interrupts received } 
    dwLost : DWORD;      { number of interrupts not yet dealt with } 
    fStopped : BOOL;     { was interrupt disabled during wait } 
 end;

type PMYDRIVER_INT_RESULT = ^MYDRIVER_INT_RESULT;

type MYDRIVER_INT_HANDLER = procedure(pWorker : POINTER; intResult : PMYDRIVER_INT_RESULT) stdcall; 

type MYDRIVER_MODE = INTEGER; 
const 
    MYDRIVER_MODE_BYTE = 0; MYDRIVER_MODE_WORD   = 1; MYDRIVER_MODE_DWORD  = 2; 

type MYDRIVER_ADDR = INTEGER; 
const
    MYDRIVER_AD_BAR0 = AD_PCI_BAR0; 
    MYDRIVER_AD_BAR1 = AD_PCI_BAR1; 
    MYDRIVER_AD_BAR2 = AD_PCI_BAR2; 
    MYDRIVER_AD_BAR3 = AD_PCI_BAR3; 
    MYDRIVER_AD_BAR4 = AD_PCI_BAR4; 
    MYDRIVER_AD_BAR5 = AD_PCI_BAR5; 
    MYDRIVER_AD_EPROM = AD_PCI_BAR_EPROM; 
    MYDRIVER_ITEMS = AD_PCI_BARS; 

type MYDRIVER_INT_INTERRUPT = record 
    Int     : WD_INTERRUPT; 
    hThread : HANDLE; 
    Trans : array [0..0] of SWD_TRANSFER; 
    funcIntHandler : MYDRIVER_INT_HANDLER; 
end; 

type MYDRIVER_ADDR_DESC = record 
    index : DWORD; 
    dwMask : DWORD; 
    fIsMemory : BOOLEAN; 
    fActive : BOOLEAN; 
end; 

type MYDRIVER_STRUCT = record 
    hWD : HANDLE; 
    fUseInt : BOOLEAN; 
    Int : MYDRIVER_INT_INTERRUPT; 
    pciSlot : WD_PCI_SLOT;
    addrDesc : array[0..MYDRIVER_ITEMS-1] of MYDRIVER_ADDR_DESC;
    cardReg : WD_CARD_REGISTER;
end; 

type MYDRIVER_HANDLE = ^MYDRIVER_STRUCT;
type PMYDRIVER_HANDLE = ^MYDRIVER_HANDLE;

type PBYTE  = ^BYTE;
type PWORD  = ^WORD;
type PDWORD = ^DWORD;

const MYDRIVER_DEFAULT_VENDOR_ID = $10B5; 
const MYDRIVER_DEFAULT_DEVICE_ID = $9050; 

{ MYDRIVER register definitions }
const MYDRIVER_Mil_cmd_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Mil_cmd_OFFSET = $8; 
const MYDRIVER_Mil_write_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Mil_write_OFFSET = $4; 
const MYDRIVER_Reset_Card_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Reset_Card_OFFSET = $c; 
const MYDRIVER_Mil_read_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Mil_read_OFFSET = $4; 
const MYDRIVER_Set_Timer1_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Set_Timer1_OFFSET = $10; 
const MYDRIVER_Mil_Status_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Mil_Status_OFFSET = $0; 
const MYDRIVER_ControlRegister1_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_ControlRegister1_OFFSET = $1c; 
const MYDRIVER_Slave_Mil_interlog_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Slave_Mil_interlog_OFFSET = $20; 
const MYDRIVER_EV_Time_Rd_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_EV_Time_Rd_OFFSET = $28; 
const MYDRIVER_Event_Read_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Event_Read_OFFSET = $24; 
const MYDRIVER_Intrrrupt_Mask_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Intrrrupt_Mask_OFFSET = $2c; 
const MYDRIVER_Aux_IO_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Aux_IO_OFFSET = $30; 
const MYDRIVER_Set_Timer2_10us_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Set_Timer2_10us_OFFSET = $14; 
const MYDRIVER_Set_Timer2_1ms_SPACE = MYDRIVER_AD_BAR2; 
const MYDRIVER_Set_Timer2_1ms_OFFSET = $18; 

{ options for MYDRIVER_Open } 
const MYDRIVER_OPEN_USE_INT = $1; 

{ internal function used by MYDRIVER_Open() }
function MYDRIVER_DetectCardElements(hMYDRIVER : MYDRIVER_HANDLE) : BOOLEAN; 

procedure MYDRIVER_WritePCIReg(hMYDRIVER : MYDRIVER_HANDLE; dwReg : DWORD; dwData : DWORD);
function MYDRIVER_ReadPCIReg(hMYDRIVER : MYDRIVER_HANDLE; dwReg : DWORD) : DWORD;
function MYDRIVER_IsAddrSpaceActive(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR) : BOOLEAN;
procedure MYDRIVER_GetPciSlot(hMYDRIVER : MYDRIVER_HANDLE; pPciSlot : PWD_PCI_SLOT);
function MYDRIVER_CountCards (dwVendorID : DWORD; dwDeviceID : DWORD) : DWORD;
function MYDRIVER_Open (phMYDRIVER : PMYDRIVER_HANDLE; dwVendorId : DWORD; dwDeviceId : DWORD; nCardNum : DWORD; options : DWORD) : BOOLEAN; 
procedure MYDRIVER_Close(hMYDRIVER : MYDRIVER_HANDLE);
procedure MYDRIVER_RegisterWinDriver;
{ General read/write function }
procedure MYDRIVER_ReadWriteBlock(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; fRead : BOOLEAN; buf : POINTER; dwBytes : DWORD; mode : MYDRIVER_MODE);
function MYDRIVER_ReadByte(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD) : BYTE;
function MYDRIVER_ReadWord(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD) : WORD;
function MYDRIVER_ReadDword(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD) : DWORD;
procedure MYDRIVER_WriteByte(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; data : BYTE);
procedure MYDRIVER_WriteWord(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; data : WORD);
procedure MYDRIVER_WriteDword(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; data : DWORD);
{  }
 procedure MYDRIVER_WriteMil_cmd(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 procedure MYDRIVER_WriteMil_write(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 procedure MYDRIVER_WriteReset_Card(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 function MYDRIVER_ReadMil_read(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
{  }
 procedure MYDRIVER_WriteSet_Timer1(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 function MYDRIVER_ReadMil_Status(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
{  }
 procedure MYDRIVER_WriteControlRegister1(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 procedure MYDRIVER_WriteSlave_Mil_interlog(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 function MYDRIVER_ReadEV_Time_Rd(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
{  }
 function MYDRIVER_ReadEvent_Read(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
{  }
 function MYDRIVER_ReadIntrrrupt_Mask(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
procedure MYDRIVER_WriteIntrrrupt_Mask(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 function MYDRIVER_ReadAux_IO(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
procedure MYDRIVER_WriteAux_IO(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 procedure MYDRIVER_WriteSet_Timer2_10us(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
{  }
 procedure MYDRIVER_WriteSet_Timer2_1ms(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);

{ handle interrupts }
{  }
function MYDRIVER_IntIsEnabled (hMYDRIVER : MYDRIVER_HANDLE) : BOOLEAN;
procedure MYDRIVER_IntHandler (pData : POINTER);
function MYDRIVER_IntEnable (hMYDRIVER : MYDRIVER_HANDLE; funcIntHandler : MYDRIVER_INT_HANDLER) : BOOLEAN;
procedure MYDRIVER_IntDisable (hMYDRIVER : MYDRIVER_HANDLE);


implementation

function MYDRIVER_CountCards (dwVendorID : DWORD; dwDeviceID : DWORD) : DWORD;
var
    ver : SWD_VERSION;
    pciScan : WD_PCI_SCAN_CARDS;
    hWD : HANDLE;

begin
    MYDRIVER_RegisterWinDriver();

    MYDRIVER_ErrorString := '';
    hWD := WD_Open();
    { check if handle valid & version OK }
    if hWD = INVALID_HANDLE_VALUE
    then
    begin
        MYDRIVER_ErrorString := 'Failed opening WinDriver device';
        MYDRIVER_CountCards := 0;
    end
    else
    begin
        FillChar(ver, SizeOf(ver), 0);
        WD_Version(hWD,ver);
        if ver.dwVer < WD_VER 
        then
        begin
            MYDRIVER_ErrorString := 'Incorrect WinDriver version';
            WD_Close (hWD);
            MYDRIVER_CountCards := 0;
        end
        else
        begin
            FillChar(pciScan, SizeOf(pciScan), 0);
            pciScan.searchId.dwVendorId := dwVendorID;
            pciScan.searchId.dwDeviceId := dwDeviceID;
            WD_PciScanCards (hWD, pciScan);
            WD_Close (hWD);
            if (pciScan.dwCards = 0)
            then
                MYDRIVER_ErrorString := 'no cards found';
        end;
    end;
    MYDRIVER_CountCards := pciScan.dwCards;
end;


function MYDRIVER_Open (phMYDRIVER : PMYDRIVER_HANDLE; dwVendorID : DWORD; dwDeviceID : DWORD; nCardNum : DWORD; options : DWORD) : BOOLEAN; 
var 
    hMYDRIVER : MYDRIVER_HANDLE; 
    ver : SWD_VERSION; 
    i : DWORD;
    pItem : PWD_ITEMS;
    pciScan    : WD_PCI_SCAN_CARDS;
    pciCardInfo : WD_PCI_CARD_INFO;

label Finish;

begin
    GetMem (POINTER(hMYDRIVER), sizeof (MYDRIVER_STRUCT));


    phMYDRIVER^ := nil;
    MYDRIVER_ErrorString := '';
    FillChar(hMYDRIVER^, SizeOf(hMYDRIVER^), 0);

    MYDRIVER_RegisterWinDriver();

    hMYDRIVER^.cardReg.hCard := 0;
    hMYDRIVER^.hWD := WD_Open();

    { check if handle valid & version OK }
    if hMYDRIVER^.hWD = INVALID_HANDLE_VALUE
    then 
    begin 
        MYDRIVER_ErrorString := 'Failed opening WinDriver device';
        goto Finish;
    end;

    FillChar(ver, SizeOf(ver), 0);
    WD_Version(hMYDRIVER^.hWD,ver);
    if (ver.dwVer < WD_VER)
    then 
    begin 
        MYDRIVER_ErrorString := 'Incorrect WinDriver version';
        goto Finish;
    end;

    FillChar(pciScan, SizeOf(pciScan), 0);
    pciScan.searchId.dwVendorId := dwVendorID;
    pciScan.searchId.dwDeviceId := dwDeviceID;
    WD_PciScanCards (hMYDRIVER^.hWD, pciScan);
    if pciScan.dwCards = 0            { One card at least must be found}
    then
    begin
        MYDRIVER_ErrorString := 'Could not find PCI card';
        goto Finish;
    end;
    if pciScan.dwCards <= nCardNum
    then
    begin
        MYDRIVER_ErrorString := 'Card out of range of available cards';
        goto Finish;
    end;

    FillChar(pciCardInfo, sizeof(pciCardInfo), 0);
    pciCardInfo.pciSlot := pciScan.cardSlot[nCardNum];
    WD_PciGetCardInfo (hMYDRIVER^.hWD, pciCardInfo);
    hMYDRIVER^.pciSlot := pciCardInfo.pciSlot;
    hMYDRIVER^.cardReg.Card := pciCardInfo.Card;

    if (options <> 0) and (MYDRIVER_OPEN_USE_INT > 0)
    then
        hMYDRIVER^.fUseInt :=  True
    else
        hMYDRIVER^.fUseInt :=  False;
    if not hMYDRIVER^.fUseInt
    then
    begin
        { Remove interrupt item if not needed }
        for i:=1 to hMYDRIVER^.cardReg.Card.dwItems do
        begin
            pItem := @hMYDRIVER^.cardReg.Card.Item[i-1];
            if pItem^.item = ITEM_INTERRUPT
            then
                pItem^.item := ITEM_NONE;
        end;
    end
    else
    begin
        { make interrupt resource sharable }
        for i:=1 to hMYDRIVER^.cardReg.Card.dwItems do
        begin
            pItem := @hMYDRIVER^.cardReg.Card.Item[i-1];
            if pItem^.item = ITEM_INTERRUPT
            then
                pItem^.fNotSharable := 0;
        end;
    end;

    hMYDRIVER^.cardReg.fCheckLockOnly := 0;
    WD_CardRegister(hMYDRIVER^.hWD, hMYDRIVER^.cardReg);
    if hMYDRIVER^.cardReg.hCard = 0
    then
    begin
        MYDRIVER_ErrorString := 'Failed locking device';
        goto Finish;
    end;

    if not MYDRIVER_DetectCardElements(hMYDRIVER)
    then
    begin
        MYDRIVER_ErrorString := 'Card does not have all items expected for MYDRIVER';
        goto Finish;
    end;

    { Open finished OK }
    phMYDRIVER^ := hMYDRIVER;
    MYDRIVER_Open := True;
    Exit;

Finish:    { Error during Open }
    if hMYDRIVER^.cardReg.hCard <> 0 
    then
        WD_CardUnregister(hMYDRIVER^.hWD, hMYDRIVER^.cardReg);
    if (hMYDRIVER^.hWD <> INVALID_HANDLE_VALUE)
    then
        WD_Close(hMYDRIVER^.hWD);
    FreeMem(hMYDRIVER);
    MYDRIVER_Open := False;
end;


procedure MYDRIVER_Close(hMYDRIVER : MYDRIVER_HANDLE);
begin
    { disable interrupts }
    if MYDRIVER_IntIsEnabled(hMYDRIVER)
    then
        MYDRIVER_IntDisable(hMYDRIVER);

    { unregister card }
    if hMYDRIVER^.cardReg.hCard <> 0 
    then
        WD_CardUnregister(hMYDRIVER^.hWD, hMYDRIVER^.cardReg);

    { close WinDriver }
    WD_Close(hMYDRIVER^.hWD);

    FreeMem(hMYDRIVER);
end;


procedure MYDRIVER_RegisterWinDriver;
var
    hWD : HANDLE;
    lic : SWD_LICENSE;

begin
    hWD := WD_Open();
    if hWD <> INVALID_HANDLE_VALUE
    then
    begin
        lic.cLicense := '6a2b4ee4645cbafddf2c727ef9c4748e6a93.GSI';
        WD_License(hWD, lic);
        WD_Close(hWD);
    end;
end;


procedure MYDRIVER_WritePCIReg(hMYDRIVER : MYDRIVER_HANDLE; dwReg : DWORD; dwData : DWORD);
var
    pciCnf : WD_PCI_CONFIG_DUMP;

begin
    FillChar(pciCnf, SizeOf(pciCnf), 0);
    pciCnf.pciSlot := hMYDRIVER^.pciSlot;
    pciCnf.pBuffer := @dwData;
    pciCnf.dwOffset := dwReg;
    pciCnf.dwBytes := 4;
    pciCnf.fIsRead := 0;
    WD_PciConfigDump(hMYDRIVER^.hWD, pciCnf);
end;


function MYDRIVER_ReadPCIReg(hMYDRIVER : MYDRIVER_HANDLE; dwReg : DWORD) : DWORD;
var
    pciCnf : WD_PCI_CONFIG_DUMP;
    dwVal : DWORD;

begin
    FillChar(pciCnf, SizeOf(pciCnf), 0);
    pciCnf.pciSlot := hMYDRIVER^.pciSlot;
    pciCnf.pBuffer := @dwVal;
    pciCnf.dwOffset := dwReg;
    pciCnf.dwBytes := 4;
    pciCnf.fIsRead := 1;
    WD_PciConfigDump(hMYDRIVER^.hWD, pciCnf);
    MYDRIVER_ReadPCIReg := dwVal;
end;


function MYDRIVER_DetectCardElements(hMYDRIVER : MYDRIVER_HANDLE) : BOOLEAN; 
var
    i,j, iCntr : DWORD;
    ad_sp      : DWORD;
    pItem      : PWD_ITEMS;
    dwBytes    : DWORD;
    dwPhysAddr : DWORD;
    fIsMemory  : BOOLEAN;
    dwPCIAddr  : DWORD;
    dwPCIReg   : DWORD;
    res        : BOOLEAN;

begin
    res := True;
    FillChar(hMYDRIVER^.Int, SizeOf(hMYDRIVER^.Int), 0);
    FillChar(hMYDRIVER^.addrDesc, SizeOf(hMYDRIVER^.addrDesc), 0);
    for i:=1 to hMYDRIVER^.cardReg.Card.dwItems do
    begin
        if not res
        then
            Break;
        pItem := @hMYDRIVER^.cardReg.Card.Item[i-1];
        case pItem^.item of
        ITEM_MEMORY, ITEM_IO:
            begin
                if pItem^.item = ITEM_MEMORY
                then
                begin
                    dwBytes := pItem^.Memory.dwMBytes;
                    dwPhysAddr := pItem^.Memory.dwPhysicalAddr;
                    fIsMemory := True;
                end
                else 
                begin
                    dwBytes := pItem^.IO.dwBytes;
                    dwPhysAddr := pItem^.IO.dwAddr;
                    fIsMemory := False;
                end;

                for ad_sp:=1 to MYDRIVER_ITEMS do
                begin
                    iCntr := ad_sp-1;
                    if MYDRIVER_IsAddrSpaceActive(hMYDRIVER, MYDRIVER_ADDR (ad_sp-1))
                    then
                        Continue;
                    if (ad_sp-1 < MYDRIVER_AD_EPROM)
                    then
                        dwPCIReg := PCI_BAR0 + 4*(ad_sp-1)
                    else
                        dwPCIReg := PCI_ERBAR;
                    dwPCIAddr := MYDRIVER_ReadPCIReg(hMYDRIVER, dwPCIReg);
                    if (dwPCIAddr and 1) <> 0
                    then
                    begin
                        if (fIsMemory)
                        then
                            Continue;
                        dwPCIAddr := dwPCIAddr and (not $3);
                    end
                    else
                    begin
                        if (not fIsMemory)
                        then
                            Continue;
                        dwPCIAddr := dwPCIAddr and (not $f);
                    end;
                    if (dwPCIAddr = dwPhysAddr)
                    then
                        Break;
                end;
                if (iCntr < MYDRIVER_ITEMS)
                then
                begin
                    hMYDRIVER^.addrDesc[iCntr].fActive := True;
                    hMYDRIVER^.addrDesc[iCntr].index := i-1;
                    hMYDRIVER^.addrDesc[iCntr].fIsMemory := fIsMemory;
                    hMYDRIVER^.addrDesc[iCntr].dwMask := 0;
                    j:=1;
                    while (j<dwBytes) and (j<>$80000000) do
                    begin
                        hMYDRIVER^.addrDesc[iCntr].dwMask := (hMYDRIVER^.addrDesc[iCntr].dwMask shl 1) or 1;
                        j := j*2;
                    end;
                end;
            end;
        ITEM_INTERRUPT:
            begin
                if hMYDRIVER^.Int.Int.hInterrupt <> 0
                then
                begin
                    res := False;
                    Break;
                end;
                hMYDRIVER^.Int.Int.hInterrupt := pItem^.Interrupt.hInterrupt;
            end;
        end;
    end;

    { check that all the items needed were found }
    { check whether an interrupt found }
    if (hMYDRIVER^.fUseInt) and (hMYDRIVER^.Int.Int.hInterrupt = 0) 
    then
        res := False;

    { check that at least one memory space was found }
    res := False;
    for i := 1 to MYDRIVER_ITEMS do
        if (MYDRIVER_IsAddrSpaceActive(hMYDRIVER, MYDRIVER_ADDR (i-1)))
        then
            res := True;
    MYDRIVER_DetectCardElements := res;
end;


function MYDRIVER_IsAddrSpaceActive(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR) : BOOLEAN;
begin
    MYDRIVER_IsAddrSpaceActive := hMYDRIVER^.addrDesc[addrSpace].fActive;
end;


procedure MYDRIVER_GetPciSlot(hMYDRIVER : MYDRIVER_HANDLE; pPciSlot : PWD_PCI_SLOT);
begin
    pPciSlot^ := hMYDRIVER^.pciSlot;
end;


{ General read/write function }
procedure MYDRIVER_ReadWriteBlock(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; fRead : BOOLEAN; buf : POINTER; dwBytes : DWORD; mode : MYDRIVER_MODE);
var
    trans : SWD_TRANSFER;
    fMem : BOOLEAN;

begin
    fMem := hMYDRIVER^.addrDesc[addrSpace].fIsMemory;
               { safety check: is the address range active? }
    if (not MYDRIVER_IsAddrSpaceActive(hMYDRIVER, addrSpace))
    then
        Exit;
    FillChar(trans, SizeOf(trans), 0);
    if fRead
    then
    case mode of
        MYDRIVER_MODE_BYTE :
            if fMem
            then
                trans.cmdTrans := RM_SBYTE
            else
                trans.cmdTrans := RP_SBYTE;
        MYDRIVER_MODE_WORD :
            if (fMem)
            then
                trans.cmdTrans := RM_SWORD
            else
                trans.cmdTrans := RP_SWORD;
        MYDRIVER_MODE_DWORD :
            if (fMem)
            then
                trans.cmdTrans := RM_SDWORD
            else
                trans.cmdTrans := RP_SDWORD;
    end
    else
    case mode of
        MYDRIVER_MODE_BYTE :
            if (fMem)
            then
                trans.cmdTrans := WM_SBYTE
            else
                trans.cmdTrans := WP_SBYTE;
        MYDRIVER_MODE_WORD :
            if (fMem)
            then
                trans.cmdTrans := WM_SWORD
            else
                trans.cmdTrans := WP_SWORD;
        MYDRIVER_MODE_DWORD :
            if (fMem)
            then
                trans.cmdTrans := WM_SDWORD
            else
                trans.cmdTrans := WP_SDWORD;
    end;
    if (fMem)
    then
        trans.dwPort := hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwTransAddr
    else
        trans.dwPort := hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].IO.dwAddr;
    trans.dwPort := trans.dwPort + dwOffset;

    trans.fAutoinc := 1;
    trans.dwBytes := dwBytes;
    trans.dwOptions := 0;
    trans.pBuffer := buf;
    WD_Transfer (hMYDRIVER^.hWD, trans);
end;


function MYDRIVER_ReadByte(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD) : BYTE;
var
    data : BYTE;
    pData : PBYTE;

begin
    if hMYDRIVER^.addrDesc[addrSpace].fIsMemory
    then
    begin
        pData := PBYTE(hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwUserDirectAddr + dwOffset);
        data := pData^;             { read from the memory mapped range directly }
    end
    else
        MYDRIVER_ReadWriteBlock( hMYDRIVER, addrSpace, dwOffset, True, @data, SizeOf(BYTE), MYDRIVER_MODE_BYTE);
    MYDRIVER_ReadByte := data;
end;


function MYDRIVER_ReadWord(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD) : WORD;
var
    data : WORD;
    pData : PWORD;

begin
    if hMYDRIVER^.addrDesc[addrSpace].fIsMemory
    then
    begin
        pData := PWORD(hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwUserDirectAddr + dwOffset);
        data := pData^;             { read from the memory mapped range directly }
    end
    else
        MYDRIVER_ReadWriteBlock( hMYDRIVER, addrSpace, dwOffset, True, @data, SizeOf(WORD), MYDRIVER_MODE_WORD);
    MYDRIVER_ReadWord := data;
end;


function MYDRIVER_ReadDword(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD) : DWORD;
var
    data : DWORD;
    pData : PDWORD;

begin
    if hMYDRIVER^.addrDesc[addrSpace].fIsMemory
    then
    begin
        pData := PDWORD(hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwUserDirectAddr + dwOffset);
        data := pData^;             { read from the memory mapped range directly }
    end
    else
        MYDRIVER_ReadWriteBlock( hMYDRIVER, addrSpace, dwOffset, True, @data, SizeOf(DWORD), MYDRIVER_MODE_DWORD);
    MYDRIVER_ReadDword := data;
end;


procedure MYDRIVER_WriteByte(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; data : BYTE);
var
    pData : PBYTE;

begin
    if hMYDRIVER^.addrDesc[addrSpace].fIsMemory
    then
    begin
        pData := PBYTE(hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwUserDirectAddr + dwOffset);
        pData^ := data;             { write to the memory mapped range directly }
    end
    else
        MYDRIVER_ReadWriteBlock( hMYDRIVER, addrSpace, dwOffset, False, @data, SizeOf(BYTE), MYDRIVER_MODE_BYTE);
end;


procedure MYDRIVER_WriteWord(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; data : WORD);
var
    pData : PWORD;

begin
    if hMYDRIVER^.addrDesc[addrSpace].fIsMemory
    then
    begin
        pData := PWORD(hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwUserDirectAddr + dwOffset);
        pData^ := data;             { write to the memory mapped range directly }
    end
    else
        MYDRIVER_ReadWriteBlock( hMYDRIVER, addrSpace, dwOffset, False, @data, SizeOf(WORD), MYDRIVER_MODE_WORD);
end;


procedure MYDRIVER_WriteDword(hMYDRIVER : MYDRIVER_HANDLE; addrSpace : MYDRIVER_ADDR; dwOffset : DWORD; data : DWORD);
var
    pData : PDWORD;

begin
    if hMYDRIVER^.addrDesc[addrSpace].fIsMemory
    then
    begin
        pData := PDWORD(hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwUserDirectAddr + dwOffset);
        pData^ := data;             { write to the memory mapped range directly }
    end
    else
        MYDRIVER_ReadWriteBlock( hMYDRIVER, addrSpace, dwOffset, False, @data, SizeOf(DWORD), MYDRIVER_MODE_DWORD);
end;


procedure MYDRIVER_WriteMil_cmd(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Mil_cmd_SPACE), MYDRIVER_Mil_cmd_OFFSET, data);
end;

procedure MYDRIVER_WriteMil_write(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Mil_write_SPACE), MYDRIVER_Mil_write_OFFSET, data);
end;

procedure MYDRIVER_WriteReset_Card(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Reset_Card_SPACE), MYDRIVER_Reset_Card_OFFSET, data);
end;

function MYDRIVER_ReadMil_read(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
begin
    MYDRIVER_ReadMil_read := MYDRIVER_ReadDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Mil_read_SPACE), MYDRIVER_Mil_read_OFFSET);
end;

procedure MYDRIVER_WriteSet_Timer1(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Set_Timer1_SPACE), MYDRIVER_Set_Timer1_OFFSET, data);
end;

function MYDRIVER_ReadMil_Status(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
begin
    MYDRIVER_ReadMil_Status := MYDRIVER_ReadDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Mil_Status_SPACE), MYDRIVER_Mil_Status_OFFSET);
end;

procedure MYDRIVER_WriteControlRegister1(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_ControlRegister1_SPACE), MYDRIVER_ControlRegister1_OFFSET, data);
end;

procedure MYDRIVER_WriteSlave_Mil_interlog(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Slave_Mil_interlog_SPACE), MYDRIVER_Slave_Mil_interlog_OFFSET, data);
end;

function MYDRIVER_ReadEV_Time_Rd(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
begin
    MYDRIVER_ReadEV_Time_Rd := MYDRIVER_ReadDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_EV_Time_Rd_SPACE), MYDRIVER_EV_Time_Rd_OFFSET);
end;

function MYDRIVER_ReadEvent_Read(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
begin
    MYDRIVER_ReadEvent_Read := MYDRIVER_ReadDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Event_Read_SPACE), MYDRIVER_Event_Read_OFFSET);
end;

function MYDRIVER_ReadIntrrrupt_Mask(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
begin
    MYDRIVER_ReadIntrrrupt_Mask := MYDRIVER_ReadDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Intrrrupt_Mask_SPACE), MYDRIVER_Intrrrupt_Mask_OFFSET);
end;

procedure MYDRIVER_WriteIntrrrupt_Mask(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Intrrrupt_Mask_SPACE), MYDRIVER_Intrrrupt_Mask_OFFSET, data);
end;

function MYDRIVER_ReadAux_IO(hMYDRIVER : MYDRIVER_HANDLE) : DWORD;
begin
    MYDRIVER_ReadAux_IO := MYDRIVER_ReadDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Aux_IO_SPACE), MYDRIVER_Aux_IO_OFFSET);
end;

procedure MYDRIVER_WriteAux_IO(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Aux_IO_SPACE), MYDRIVER_Aux_IO_OFFSET, data);
end;

procedure MYDRIVER_WriteSet_Timer2_10us(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Set_Timer2_10us_SPACE), MYDRIVER_Set_Timer2_10us_OFFSET, data);
end;

procedure MYDRIVER_WriteSet_Timer2_1ms(hMYDRIVER : MYDRIVER_HANDLE; data : DWORD);
begin
    MYDRIVER_WriteDword(hMYDRIVER, MYDRIVER_ADDR (MYDRIVER_Set_Timer2_1ms_SPACE), MYDRIVER_Set_Timer2_1ms_OFFSET, data);
end;


function MYDRIVER_IntIsEnabled (hMYDRIVER : MYDRIVER_HANDLE) : BOOLEAN;
begin
   MYDRIVER_IntIsEnabled := True;
    if (not hMYDRIVER^.fUseInt)
    then
        MYDRIVER_IntIsEnabled := False;
    if hMYDRIVER^.Int.hThread = 0
    then
        MYDRIVER_IntIsEnabled := False;
end;

procedure MYDRIVER_IntHandler (pData : POINTER);
var
    hMYDRIVER       : MYDRIVER_HANDLE;
    intResult : MYDRIVER_INT_RESULT;

begin
    hMYDRIVER := MYDRIVER_HANDLE (pData);
    intResult.dwCounter := hMYDRIVER^.Int.Int.dwCounter;
    intResult.dwLost := hMYDRIVER^.Int.Int.dwLost;
    intResult.fStopped := BOOLEAN(hMYDRIVER^.Int.Int.fStopped);
    hMYDRIVER^.Int.funcIntHandler(POINTER(hMYDRIVER), @intResult);
end;


function MYDRIVER_IntEnable (hMYDRIVER : MYDRIVER_HANDLE; funcIntHandler : MYDRIVER_INT_HANDLER) : BOOLEAN;
var
     addrSpace : MYDRIVER_ADDR;

begin
    if (not hMYDRIVER^.fUseInt)
    then
        MYDRIVER_IntEnable := False
    else
        if hMYDRIVER^.Int.hThread<>0        { check if interrupt is already enabled }
        then
            MYDRIVER_IntEnable := False
        else
        begin
            FillChar(hMYDRIVER^.Int.Trans, SizeOf(hMYDRIVER^.Int.Trans), 0);
            { This is a sample of handling interrupts:                                  }
             { One transfer command is issued to CANCEL the source of the interrupt,     }
             { otherwise, the PC will hang when an interrupt occurs!                     }
            { You will need to modify this code to fit your specific hardware.          }

            addrSpace := MYDRIVER_AD_BAR0;             (* put the address space of the register here *)
 
            if hMYDRIVER^.addrDesc[addrSpace].fIsMemory
            then
            begin
                hMYDRIVER^.Int.Trans[0].dwPort := hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].Memory.dwTransAddr;
                hMYDRIVER^.Int.Trans[0].cmdTrans := WM_DWORD;
            end
            else
            begin
                hMYDRIVER^.Int.Trans[0].dwPort := hMYDRIVER^.cardReg.Card.Item[hMYDRIVER^.addrDesc[addrSpace].index].IO.dwAddr;
                hMYDRIVER^.Int.Trans[0].cmdTrans := WP_DWORD;
            end;
            hMYDRIVER^.Int.Trans[0].dwPort := hMYDRIVER^.Int.Trans[0].dwPort + 0;
                    { put the offset of the register from the beginning of the address space here }
            hMYDRIVER^.Int.Trans[0].ADword := $0;
            hMYDRIVER^.Int.Int.dwCmds := 1;
            hMYDRIVER^.Int.Int.Cmd := @hMYDRIVER^.Int.Trans[0];
            hMYDRIVER^.Int.Int.dwOptions := hMYDRIVER^.Int.Int.dwOptions or INTERRUPT_CMD_COPY;

            { this calls WD_IntEnable() and creates an interrupt handler thread }
            hMYDRIVER^.Int.funcIntHandler := funcIntHandler;
            if not InterruptThreadEnable(@hMYDRIVER^.Int.hThread, hMYDRIVER^.hWD, @hMYDRIVER^.Int.Int, MYDRIVER_IntHandler, POINTER(hMYDRIVER))
            then
                MYDRIVER_IntEnable := False
            else
                MYDRIVER_IntEnable := True;
        end;
end;


procedure MYDRIVER_IntDisable (hMYDRIVER : MYDRIVER_HANDLE);
begin
    if hMYDRIVER^.fUseInt
    then
    if hMYDRIVER^.Int.hThread <> 0
    then
     begin
        { this calls WD_IntDisable() }
        InterruptThreadDisable(hMYDRIVER^.Int.hThread);
        hMYDRIVER^.Int.hThread := 0;
    end;
end;



end.
